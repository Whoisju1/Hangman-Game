/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__style_main_scss__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__style_main_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__style_main_scss__);\n\n//import styles\n\n\n\nconst HANGMAN = {};\n\n// -------------------------NAMESPACE -------------------------\n(namespace => {\n\t// -----------------------WORD CLASS------------------------\n\t// used to make words for game\n\tclass Word {\n\t\tconstructor(word, hint) {\n\t\t\tthis.word = word.toLowerCase();\n\t\t\tthis.hint = hint;\n\t\t\tthis.isMatched = this.isMatched.bind(this);\n\t\t\tthis.isIncluded = this.isIncluded.bind(this);\n\t\t}\n\n\t\t// method to test if user letter choice is present in word\n\t\tisIncluded(char) {\n\t\t\treturn this.word.includes(char.toLowerCase().trim());\n\t\t}\n\n\t\t//method to test if word is correct\n\t\tisMatched(letters) {\n\t\t\treturn this.word === letters.toLowerCase().trim() ? true : false;\n\t\t}\n\t}\n\n\t// ----------------------WORD FACTORY------------------------\n\t// make single word or an array of words and make it a property of HANGMAN\n\t// it takes an a single string, multiple stings, or an array of stings as an argument\n\tHANGMAN.wordFactory = (...word) => {\n\t\t// if argument is an array make it an array by destructuring it\n\t\tif (Array.isArray(...word)) [word] = word;\n\t\t// iterate through an array of strings and return an array of objects\n\t\tif (word.length > 1) return word.map(item => new Word(...item));\n\n\t\t// if argument is a single string destructure the array and output a string\n\t\tconst [singleWord] = word;\n\t\t// make a single object\n\t\treturn new Word(singleWord);\n\t};\n\n\t// ------------------ARRAY ITERATOR ----------------------------------\n\n\t// loop through array of words and execute callback function using recursive function\n\tconst arrayIterator = (wordList, cb) => {\n\t\tconst [a, ...b] = wordList;\n\t\tcb(a);\n\t\tif (wordList.length === 1) return;\n\t\tarrayIterator(b, cb);\n\t};\n\n\tHANGMAN.arrayIterator = arrayIterator;\n\n\t// This method takes in a string and outputs a string of underscores\n\t// proportionate to the number of characters contained in the string\n\tconst makeDashes = answer => {\n\t\tlet dashed = [];\n\t\t(function looper(answer) {\n\t\t\tlet [a, ...b] = [...answer];\n\n\t\t\tdashed.push('_');\n\t\t\tif (answer.length === 1) return;\n\t\t\tlooper(b);\n\t\t})(answer);\n\t\treturn dashed.join('');\n\t};\n\n\tHANGMAN.makeDashes = makeDashes;\n\n\t// this is a method used for DOM manipulation\n\t// the names of the functions within it borrow from jQuery\n\tconst makeElem = elemName => {\n\t\tlet elem = document.createElement(elemName = 'div');\n\n\t\t// insert element into another element\n\t\telem.appendTo = parent => {\n\t\t\tparent.appendChild(elem);\n\t\t\treturn elem;\n\t\t};\n\n\t\t// add text to element\n\t\telem.text = text => {\n\t\t\telem.textContent = text;\n\t\t\treturn elem;\n\t\t};\n\n\t\t// add HTML to element\n\t\telem.html = html => {\n\t\t\telem.innerHTML = html;\n\t\t\treturn elem;\n\t\t};\n\n\t\t// empty the element of all it's content\n\t\telem.empty = () => {\n\t\t\telem.innerHTML = '';\n\t\t\treturn elem;\n\t\t};\n\n\t\t// hide the element\n\t\telem.hide = () => {\n\t\t\telem.style.visibility = 'hidden';\n\t\t\treturn elem;\n\t\t};\n\n\t\t// show element\n\t\telem.show = () => {\n\t\t\telem.style.visibility = 'visible';\n\t\t\treturn elem;\n\t\t};\n\n\t\t// add CSS class to element\n\t\telem.addClass = className => {\n\t\t\telem.classList.add(className);\n\t\t\treturn elem;\n\t\t};\n\n\t\t// remove CSS class from element\n\t\telem.removeClass = className => {\n\t\t\telem.classList.remove(className);\n\t\t\treturn elem;\n\t\t};\n\n\t\treturn elem;\n\t};\n\n\tHANGMAN.makeElem = makeElem;\n\n\t// window.onresize = (e) => {\n\t// \t// const func = e.getMatchedCSSRules();\n\t// \t// console.log(func);\n\t// \tconsole.log(e);\n\t// };\n\t// this takes in two arguments, the answer and the user's guess\n\t// if the letter guess is present in the answer it outputs an array of objects with the\n\t// letter as a string and the index at which the letter is present in the answer string\n\tlet guesses = (answer, letterGuessed) => {\n\t\treturn (\n\t\t\t// spread the characters in the string and place them in an array\n\t\t\t// then iterate through them using the reduce function which returns a array that contains\n\t\t\t// all the letter guessed and the the index at which it is matched in the answers string\n\t\t\t[...answer].reduce((arr, letter, index) => {\n\t\t\t\tif (letterGuessed === letter) {\n\t\t\t\t\tlet obj = {\n\t\t\t\t\t\tkey: letterGuessed,\n\t\t\t\t\t\tindex: index\n\t\t\t\t\t};\n\t\t\t\t\tarr.push(obj);\n\t\t\t\t}\n\t\t\t\treturn arr;\n\t\t\t}, [])\n\t\t);\n\t};\n\n\tHANGMAN.guesses = guesses;\n\n\t// replaces characters in a string where with provided replacement character and index where it should be placed\n\t// it receives two arguments, a string and an array of objects containing a character the user guessed and it's index in the answer\n\t// all characters provided are contained in the answer\n\tconst replace = (word, input) => {\n\t\tlet resultStr = input.reduce((previous, guess) => {\n\t\t\t// insert each letter according to it's provided index\n\t\t\tif (guess.index !== -1) return previous.substring(0, guess.index) + guess.key + previous.substring(guess.index + 1, previous.length);\n\t\t}, word);\n\n\t\t// return altered string as output\n\t\treturn resultStr;\n\t};\n\n\tHANGMAN.replace = replace;\n\n\t// takes in a number increments it by one and returns the incremented number\n\tconst inc = (num = -1) => num + 1;\n\n\tHANGMAN.inc = inc;\n})(HANGMAN);\n\nconst gameWords = HANGMAN.wordFactory([['boxer', \"It could be a man or a dog.\"], ['compliment', \"Say something to make me smile.\"], ['basketball', 'Nothing but net.'], ['hibernate', 'I can bare the cold.']]);\nconst { makeElem, makeDashes, guesses, replace, inc } = HANGMAN;\nconst methodsArr = [makeElem, makeDashes, guesses, replace, inc];\n\nconst gameConfig = (words, methods) => {\n\n\tconst wrapQuestMark = word => {\n\t\tconst wordArr = [...word].map(letter => {\n\t\t\tif (letter === '_') return `<span class=\"display__content--unsolved\">${letter}</span>`;\n\t\t\treturn letter;\n\t\t});\n\t\treturn wordArr.join('');\n\t};\n\n\tconst [makeElem, makeDashes, guesses, replace, inc] = methods;\n\n\t// create and place elements into DOM when game inintally starts\n\tconst game = makeElem().addClass('game').appendTo(document.body);\n\n\tconst displayHead__score = makeElem().addClass('display__heading').addClass('display__heading--score').appendTo(game);\n\n\tconst displayContent__word = makeElem().addClass('display__content').addClass('display__content--word').appendTo(game);\n\n\tconst wrongGuessesDiv = makeElem().addClass('wrong-guesses').appendTo(game);\n\n\tconst displayHead__hint = makeElem().addClass('game__hint-head').addClass('display__heading').addClass('display__heading--hint').appendTo(game).text('Hint');\n\n\tconst displayContent__hint = makeElem().addClass('display__content').addClass('display__content--hint').html(`\n\t\t\t<p class=\"game-text hint-text\">${words[0].hint}</p>\n\t\t`).appendTo(game);\n\n\tconst body = document.body;\n\n\t// set initial values for game\n\n\tlet input = [];\n\n\t// this sets the count to zero\n\t// the inc function returns zero when it is passed no arguments\n\t// otherwise it takes a number as an argument and turns that number incremented by 1\n\t// inc(5) is 5 + 1, which returns 6.\n\n\tlet count = inc();\n\n\tlet { word } = words[count];\n\n\tlet wins = 0;\n\n\tlet chances = 5;\n\n\tlet guessedLetters = [];\n\n\tlet puzzleWord = makeDashes(word);\n\n\t// ############ SETTING INITIAL DOM ELEMENTS ###############\n\tlet winsDiv = makeElem().addClass('game__score--wins').html(`wins: <span class=\"game__score--tally\">${wins}</span>`).appendTo(displayHead__score);\n\tlet chancesDiv = makeElem().addClass('game__score--chances').html(`chances: <span class=\"game__score--tally\">${chances}</span>`).appendTo(displayHead__score);\n\n\tlet wordProgressDiv = makeElem().addClass('game-text').addClass('display__content--text').html(wrapQuestMark(puzzleWord)).appendTo(displayContent__word);\n\n\tconst modalBackdrop = makeElem().addClass('modal__backdrop').hide().appendTo(body);\n\tconst modal = makeElem().addClass('modal').appendTo(modalBackdrop);\n\n\tconst modalMessage = makeElem().addClass('modal--message').appendTo(modal);\n\n\tlet canIncScores = true;\n\tlet acknowledgeGuesses = true;\n\n\tconst softReset = () => {\n\t\tguessedLetters = [];\n\t\tcount = inc(count);\n\t\tword = words[count].word;\n\t\tpuzzleWord = makeDashes(word);\n\t\tinput = [];\n\t\tchances = 5;\n\t\twordProgressDiv.text(`Word so far: ${puzzleWord}`);\n\t\t// print hint to screen\n\t\tdisplayContent__hint.html(`<p class=\"game-text hint-text\">${words[count].hint}</p>`).addClass('display__content');\n\n\t\twrongGuessesDiv.empty();\n\t};\n\n\t// RESTARTS GAME -- STARTS FROM THE BEGINNING\n\tconst hardReset = () => {\n\t\tguessedLetters = [];\n\t\tcanIncScores = true;\n\t\tcount = inc();\n\t\tword = words[count].word;\n\t\tpuzzleWord = makeDashes(word);\n\t\tinput = [];\n\t\tchances = 5;\n\t\twins = 0;\n\t\twordProgressDiv.html(wrapQuestMark(puzzleWord));\n\t\t// print hint to screen\n\t\tdisplayContent__hint.html(`\n\t\t\t<p class=\"game-text hint-text\">${words[count].hint}</p>\n\t\t`);\n\t\twrongGuessesDiv.empty();\n\t};\n\n\t// COMMENCE GAME WHEN USER PRESSES THE ENTER KEY\n\tbody.onkeyup = e => {\n\t\tconst isAlphabet = str => /^[a-zA-Z()]$/.test(str);\n\n\t\t// capture key stroke\n\t\tlet { key, ctrlKey } = e;\n\n\t\t// if key is a letter turn it to lower case and reassign it to back to key\n\t\tif (isAlphabet(key)) key = key.toLowerCase();\n\n\t\t// only preceed if CTRL isn't pressed along with alphabet key\n\t\tif (ctrlKey) return;\n\n\t\t//\n\t\tlet userGuess = guesses(word, key);\n\n\t\t// this function tests the key entered to find out if it is an alphabetical character\n\t\tconst alphabetTestPast = isAlphabet(key);\n\n\t\t// spread array and push them into the input array\n\t\tif (acknowledgeGuesses) input.push(...userGuess);\n\n\t\tpuzzleWord = replace(puzzleWord, input);\n\n\t\t// ############## USER GUESSED WRONG #############\n\t\tif (!words[count].isIncluded(key) && canIncScores === true && chances >= 1 && alphabetTestPast && !guessedLetters.includes(key)) {\n\t\t\tchances--;\n\t\t\tguessedLetters.push(key);\n\t\t\tmakeElem().addClass('wrong-letter').text(key).appendTo(wrongGuessesDiv);\n\n\t\t\twrongGuessesDiv.addClass('wiggle-animation');\n\n\t\t\tsetTimeout(() => {\n\t\t\t\twrongGuessesDiv.removeClass('wiggle-animation');\n\t\t\t}, 1000);\n\t\t}\n\n\t\t// ########## USER EXHAUSTS ALL HIS GUESSES ##############\n\t\tif (!chances) {\n\t\t\tacknowledgeGuesses = false;\n\t\t\t// alert('You lost!');\n\t\t\t// count = inc();\n\t\t\tmodalMessage.html(`<span class=\"modal__heading--loss\">You lose!</span> \n            <br> \n            The word was <span class=\"modal__notable--loss\">\"${words[count].word}\"</span>\n            <br>\n            Press <span class=\"modal__notable--loss\">\"Enter\"</span> to start over.`);\n\t\t\tmodalBackdrop.show();\n\t\t\tif (key === 'Enter') {\n\t\t\t\tcount = inc();\n\t\t\t\twins = inc();\n\t\t\t\tmodalBackdrop.hide();\n\t\t\t\twrongGuessesDiv.empty();\n\t\t\t\tacknowledgeGuesses = true;\n\t\t\t\tword = words[count].word;\n\t\t\t\tpuzzleWord = makeDashes(word);\n\t\t\t\tinput = [];\n\t\t\t\tchances = 5;\n\t\t\t\twordProgressDiv.html(wrapQuestMark(puzzleWord));\n\t\t\t\t// print hint to screen\n\t\t\t\tdisplayContent__hint.html(`\n\t\t\t\t\t<p class=\"game-text hint-text\">${words[count].hint}</p>\n\t\t\t\t`);\n\t\t\t\twinsDiv.html(`wins: <span class=\"game__score--tally\">${wins}</span>`);\n\t\t\t}\n\t\t}\n\n\t\t// print hint to screen\n\t\tdisplayContent__hint.html(`\n\t\t\t<p class=\"game-text hint-text\">${words[count].hint}</p>\n\t\t`);\n\n\t\t// ################ USER GOT ALL THE LETTERS ###############\n\t\tif (words[count].isMatched(puzzleWord)) {\n\t\t\tif (canIncScores) wins++;\n\t\t\tcanIncScores = false;\n\t\t\twinsDiv.html(`wins: <span class=\"game__score--tally\">${wins}</span>`);\n\t\t\twordProgressDiv.text(`Word so far: ${puzzleWord}`);\n\t\t\t// print hint to screen\n\t\t\tdisplayContent__hint.html(`\n\t\t\t\t<p class=\"game-text hint-text\">${words[count].hint}</p>\n\t\t\t`);\n\t\t\t// modalWordDisplay.text(puzzleWord);\n\t\t\tmodalMessage.html(`<h2 class=\"modal__heading--win\">Congratulations!</h2> \n                \n                <p class=\"modal__notable\">You're correct. The word's <span class=\"modal__notable--win\">\"${puzzleWord}\"</span>\n                Press <span class=\"modal__notable--win\">\"Enter\"</span> to attempt the next word.</p>`);\n\t\t\tmodalBackdrop.show();\n\n\t\t\t//  player completed every word -----TODO-----\n\t\t\tif (wins === words.length) {\n\t\t\t\tmodalMessage.html(`\n                    <h1 class=\"modal__heading--win\">Congratulations</h1>\n                    <p class=\"modal--message\">You've found all the words. Press Enter to over</p>\n                 `);\n\t\t\t}\n\n\t\t\t// move to next word when the user presses enter\n\t\t\tif (key === 'Enter') {\n\t\t\t\tcanIncScores = true;\n\t\t\t\t// ###### USER GOT ALL THE WORDS ########\n\t\t\t\tif (words[count] !== words[words.length - 1]) {\n\t\t\t\t\t//  to next word and reset negative record regarding eat individual word\n\t\t\t\t\tsoftReset();\n\t\t\t\t\tmodalBackdrop.hide();\n\t\t\t\t} else {\n\t\t\t\t\t// the game resets when all the words have been solved\n\t\t\t\t\thardReset();\n\t\t\t\t\tmodalBackdrop.hide();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tchancesDiv.html(`chances: <span class=\"game__score--tally\">${chances}</span>`);\n\t\twinsDiv.html(`wins: <span class=\"game__score--tally\">${wins}</span>`);\n\t\twordProgressDiv.html(wrapQuestMark(puzzleWord));\n\t};\n};\n\n// =================== EVENT HANDLER FOR STARTING GAME=======================\nconst handleKeypress = e => {\n\tconst { key, target } = e;\n\n\tconst intro = document.querySelector('.intro');\n\n\tif (key === 'Enter') {\n\t\tgameConfig(gameWords, methodsArr);\n\t\tintro.parentElement.removeChild(intro);\n\n\t\t// remove listener so that this function is only run once, when the user initially comes to the site\n\t\ttarget.removeEventListener('keypress', handleKeypress);\n\t\ttarget.removeEventListener('click', handleKeypress);\n\t}\n};\n\nfunction handleClick(e) {\n\tconst { target } = e;\n\n\tconst intro = document.querySelector('.intro');\n\n\tintro.parentElement.removeChild(intro);\n\tgameConfig(gameWords, methodsArr);\n\n\ttarget.removeEventListener('click', handleClick);\n\tdocument.body.removeEventListener('keypress', handleKeypress);\n}\n\ndocument.body.addEventListener('keypress', handleKeypress);\nconst introText = document.querySelector('.intro--text');\nintroText.onclick = handleClick;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvYXBwLmpzP2JkOWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG4vL2ltcG9ydCBzdHlsZXNcclxuaW1wb3J0ICcuL3N0eWxlL21haW4uc2Nzcyc7XHJcblxyXG5jb25zdCBIQU5HTUFOID0ge307XHJcblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tTkFNRVNQQUNFIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuKG5hbWVzcGFjZSA9PiB7XHJcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1XT1JEIENMQVNTLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblx0Ly8gdXNlZCB0byBtYWtlIHdvcmRzIGZvciBnYW1lXHJcblx0Y2xhc3MgV29yZCB7XHJcblx0XHRjb25zdHJ1Y3Rvcih3b3JkLCBoaW50KSB7XHJcblx0XHRcdHRoaXMud29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0dGhpcy5oaW50ID0gaGludDtcclxuXHRcdFx0dGhpcy5pc01hdGNoZWQgPSB0aGlzLmlzTWF0Y2hlZC5iaW5kKHRoaXMpO1xyXG5cdFx0XHR0aGlzLmlzSW5jbHVkZWQgPSB0aGlzLmlzSW5jbHVkZWQuYmluZCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBtZXRob2QgdG8gdGVzdCBpZiB1c2VyIGxldHRlciBjaG9pY2UgaXMgcHJlc2VudCBpbiB3b3JkXHJcblx0XHRpc0luY2x1ZGVkKGNoYXIpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMud29yZC5pbmNsdWRlcyhjaGFyLnRvTG93ZXJDYXNlKCkudHJpbSgpKTtcclxuXHRcdH1cclxuXHJcblx0XHQvL21ldGhvZCB0byB0ZXN0IGlmIHdvcmQgaXMgY29ycmVjdFxyXG5cdFx0aXNNYXRjaGVkKGxldHRlcnMpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMud29yZCA9PT0gbGV0dGVycy50b0xvd2VyQ2FzZSgpLnRyaW0oKSA/IHRydWUgOiBmYWxzZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1XT1JEIEZBQ1RPUlktLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHQvLyBtYWtlIHNpbmdsZSB3b3JkIG9yIGFuIGFycmF5IG9mIHdvcmRzIGFuZCBtYWtlIGl0IGEgcHJvcGVydHkgb2YgSEFOR01BTlxyXG5cdC8vIGl0IHRha2VzIGFuIGEgc2luZ2xlIHN0cmluZywgbXVsdGlwbGUgc3RpbmdzLCBvciBhbiBhcnJheSBvZiBzdGluZ3MgYXMgYW4gYXJndW1lbnRcclxuXHRIQU5HTUFOLndvcmRGYWN0b3J5ID0gKC4uLndvcmQpID0+IHtcclxuXHRcdC8vIGlmIGFyZ3VtZW50IGlzIGFuIGFycmF5IG1ha2UgaXQgYW4gYXJyYXkgYnkgZGVzdHJ1Y3R1cmluZyBpdFxyXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoLi4ud29yZCkpIFt3b3JkXSA9IHdvcmQ7XHJcblx0XHQvLyBpdGVyYXRlIHRocm91Z2ggYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgcmV0dXJuIGFuIGFycmF5IG9mIG9iamVjdHNcclxuXHRcdGlmICh3b3JkLmxlbmd0aCA+IDEpIHJldHVybiB3b3JkLm1hcChpdGVtID0+IG5ldyBXb3JkKC4uLml0ZW0pKTtcclxuXHJcblx0XHQvLyBpZiBhcmd1bWVudCBpcyBhIHNpbmdsZSBzdHJpbmcgZGVzdHJ1Y3R1cmUgdGhlIGFycmF5IGFuZCBvdXRwdXQgYSBzdHJpbmdcclxuXHRcdGNvbnN0IFtzaW5nbGVXb3JkXSA9IHdvcmQ7XHJcblx0XHQvLyBtYWtlIGEgc2luZ2xlIG9iamVjdFxyXG5cdFx0cmV0dXJuIG5ldyBXb3JkKHNpbmdsZVdvcmQpO1xyXG5cdH07XHJcblxyXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLUFSUkFZIElURVJBVE9SIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblx0Ly8gbG9vcCB0aHJvdWdoIGFycmF5IG9mIHdvcmRzIGFuZCBleGVjdXRlIGNhbGxiYWNrIGZ1bmN0aW9uIHVzaW5nIHJlY3Vyc2l2ZSBmdW5jdGlvblxyXG5cdGNvbnN0IGFycmF5SXRlcmF0b3IgPSAod29yZExpc3QsIGNiKSA9PiB7XHJcblx0XHRjb25zdCBbYSwgLi4uYl0gPSB3b3JkTGlzdDtcclxuXHRcdGNiKGEpO1xyXG5cdFx0aWYgKHdvcmRMaXN0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuO1xyXG5cdFx0YXJyYXlJdGVyYXRvcihiLCBjYik7XHJcblx0fTtcclxuXHJcblx0SEFOR01BTi5hcnJheUl0ZXJhdG9yID0gYXJyYXlJdGVyYXRvcjtcclxuXHJcblx0Ly8gVGhpcyBtZXRob2QgdGFrZXMgaW4gYSBzdHJpbmcgYW5kIG91dHB1dHMgYSBzdHJpbmcgb2YgdW5kZXJzY29yZXNcclxuXHQvLyBwcm9wb3J0aW9uYXRlIHRvIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb250YWluZWQgaW4gdGhlIHN0cmluZ1xyXG5cdGNvbnN0IG1ha2VEYXNoZXMgPSBhbnN3ZXIgPT4ge1xyXG5cdFx0bGV0IGRhc2hlZCA9IFtdO1xyXG5cdFx0KGZ1bmN0aW9uIGxvb3BlcihhbnN3ZXIpIHtcclxuXHRcdFx0bGV0IFthLCAuLi5iXSA9IFsuLi5hbnN3ZXJdO1xyXG5cclxuXHRcdFx0ZGFzaGVkLnB1c2goJ18nKTtcclxuXHRcdFx0aWYgKGFuc3dlci5sZW5ndGggPT09IDEpIHJldHVybjtcclxuXHRcdFx0bG9vcGVyKGIpO1xyXG5cdFx0fSkoYW5zd2VyKTtcclxuXHRcdHJldHVybiBkYXNoZWQuam9pbignJyk7XHJcblx0fTtcclxuXHJcblx0SEFOR01BTi5tYWtlRGFzaGVzID0gbWFrZURhc2hlcztcclxuXHJcblx0Ly8gdGhpcyBpcyBhIG1ldGhvZCB1c2VkIGZvciBET00gbWFuaXB1bGF0aW9uXHJcblx0Ly8gdGhlIG5hbWVzIG9mIHRoZSBmdW5jdGlvbnMgd2l0aGluIGl0IGJvcnJvdyBmcm9tIGpRdWVyeVxyXG5cdGNvbnN0IG1ha2VFbGVtID0gZWxlbU5hbWUgPT4ge1xyXG5cdFx0bGV0IGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KChlbGVtTmFtZSA9ICdkaXYnKSk7XHJcblxyXG5cdFx0Ly8gaW5zZXJ0IGVsZW1lbnQgaW50byBhbm90aGVyIGVsZW1lbnRcclxuXHRcdGVsZW0uYXBwZW5kVG8gPSBwYXJlbnQgPT4ge1xyXG5cdFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbSk7XHJcblx0XHRcdHJldHVybiBlbGVtO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBhZGQgdGV4dCB0byBlbGVtZW50XHJcblx0XHRlbGVtLnRleHQgPSB0ZXh0ID0+IHtcclxuXHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IHRleHQ7XHJcblx0XHRcdHJldHVybiBlbGVtO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBhZGQgSFRNTCB0byBlbGVtZW50XHJcblx0XHRlbGVtLmh0bWwgPSBodG1sID0+IHtcclxuXHRcdFx0ZWxlbS5pbm5lckhUTUwgPSBodG1sO1xyXG5cdFx0XHRyZXR1cm4gZWxlbTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gZW1wdHkgdGhlIGVsZW1lbnQgb2YgYWxsIGl0J3MgY29udGVudFxyXG5cdFx0ZWxlbS5lbXB0eSA9ICgpID0+IHtcclxuXHRcdFx0ZWxlbS5pbm5lckhUTUwgPSAnJztcclxuXHRcdFx0cmV0dXJuIGVsZW07XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIGhpZGUgdGhlIGVsZW1lbnRcclxuXHRcdGVsZW0uaGlkZSA9ICgpID0+IHtcclxuXHRcdFx0ZWxlbS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XHJcblx0XHRcdHJldHVybiBlbGVtO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBzaG93IGVsZW1lbnRcclxuXHRcdGVsZW0uc2hvdyA9ICgpID0+IHtcclxuXHRcdFx0ZWxlbS5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xyXG5cdFx0XHRyZXR1cm4gZWxlbTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gYWRkIENTUyBjbGFzcyB0byBlbGVtZW50XHJcblx0XHRlbGVtLmFkZENsYXNzID0gY2xhc3NOYW1lID0+IHtcclxuXHRcdFx0ZWxlbS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XHJcblx0XHRcdHJldHVybiBlbGVtO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyByZW1vdmUgQ1NTIGNsYXNzIGZyb20gZWxlbWVudFxyXG5cdFx0ZWxlbS5yZW1vdmVDbGFzcyA9IGNsYXNzTmFtZSA9PiB7XHJcblx0XHRcdGVsZW0uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xyXG5cdFx0XHRyZXR1cm4gZWxlbTtcclxuXHRcdH07XHJcblxyXG5cdFx0cmV0dXJuIGVsZW07XHJcblx0fTtcclxuXHJcblx0SEFOR01BTi5tYWtlRWxlbSA9IG1ha2VFbGVtO1xyXG5cclxuXHQvLyB3aW5kb3cub25yZXNpemUgPSAoZSkgPT4ge1xyXG5cdC8vIFx0Ly8gY29uc3QgZnVuYyA9IGUuZ2V0TWF0Y2hlZENTU1J1bGVzKCk7XHJcblx0Ly8gXHQvLyBjb25zb2xlLmxvZyhmdW5jKTtcclxuXHQvLyBcdGNvbnNvbGUubG9nKGUpO1xyXG5cdC8vIH07XHJcblx0Ly8gdGhpcyB0YWtlcyBpbiB0d28gYXJndW1lbnRzLCB0aGUgYW5zd2VyIGFuZCB0aGUgdXNlcidzIGd1ZXNzXHJcblx0Ly8gaWYgdGhlIGxldHRlciBndWVzcyBpcyBwcmVzZW50IGluIHRoZSBhbnN3ZXIgaXQgb3V0cHV0cyBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggdGhlXHJcblx0Ly8gbGV0dGVyIGFzIGEgc3RyaW5nIGFuZCB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGxldHRlciBpcyBwcmVzZW50IGluIHRoZSBhbnN3ZXIgc3RyaW5nXHJcblx0bGV0IGd1ZXNzZXMgPSAoYW5zd2VyLCBsZXR0ZXJHdWVzc2VkKSA9PiB7XHJcblx0XHRyZXR1cm4gKFxyXG5cdFx0XHQvLyBzcHJlYWQgdGhlIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZyBhbmQgcGxhY2UgdGhlbSBpbiBhbiBhcnJheVxyXG5cdFx0XHQvLyB0aGVuIGl0ZXJhdGUgdGhyb3VnaCB0aGVtIHVzaW5nIHRoZSByZWR1Y2UgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIGFycmF5IHRoYXQgY29udGFpbnNcclxuXHRcdFx0Ly8gYWxsIHRoZSBsZXR0ZXIgZ3Vlc3NlZCBhbmQgdGhlIHRoZSBpbmRleCBhdCB3aGljaCBpdCBpcyBtYXRjaGVkIGluIHRoZSBhbnN3ZXJzIHN0cmluZ1xyXG5cdFx0XHRbLi4uYW5zd2VyXS5yZWR1Y2UoKGFyciwgbGV0dGVyLCBpbmRleCkgPT4ge1xyXG5cdFx0XHRcdGlmIChsZXR0ZXJHdWVzc2VkID09PSBsZXR0ZXIpIHtcclxuXHRcdFx0XHRcdGxldCBvYmogPSB7XHJcblx0XHRcdFx0XHRcdGtleTogbGV0dGVyR3Vlc3NlZCxcclxuXHRcdFx0XHRcdFx0aW5kZXg6IGluZGV4XHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0YXJyLnB1c2gob2JqKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGFycjtcclxuXHRcdFx0fSwgW10pXHJcblx0XHQpO1xyXG5cdH07XHJcblxyXG5cdEhBTkdNQU4uZ3Vlc3NlcyA9IGd1ZXNzZXM7XHJcblxyXG5cdC8vIHJlcGxhY2VzIGNoYXJhY3RlcnMgaW4gYSBzdHJpbmcgd2hlcmUgd2l0aCBwcm92aWRlZCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgYW5kIGluZGV4IHdoZXJlIGl0IHNob3VsZCBiZSBwbGFjZWRcclxuXHQvLyBpdCByZWNlaXZlcyB0d28gYXJndW1lbnRzLCBhIHN0cmluZyBhbmQgYW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIGEgY2hhcmFjdGVyIHRoZSB1c2VyIGd1ZXNzZWQgYW5kIGl0J3MgaW5kZXggaW4gdGhlIGFuc3dlclxyXG5cdC8vIGFsbCBjaGFyYWN0ZXJzIHByb3ZpZGVkIGFyZSBjb250YWluZWQgaW4gdGhlIGFuc3dlclxyXG5cdGNvbnN0IHJlcGxhY2UgPSAod29yZCwgaW5wdXQpID0+IHtcclxuXHRcdGxldCByZXN1bHRTdHIgPSBpbnB1dC5yZWR1Y2UoKHByZXZpb3VzLCBndWVzcykgPT4ge1xyXG5cdFx0XHQvLyBpbnNlcnQgZWFjaCBsZXR0ZXIgYWNjb3JkaW5nIHRvIGl0J3MgcHJvdmlkZWQgaW5kZXhcclxuXHRcdFx0aWYgKGd1ZXNzLmluZGV4ICE9PSAtMSlcclxuXHRcdFx0XHRyZXR1cm4gKFxyXG5cdFx0XHRcdFx0cHJldmlvdXMuc3Vic3RyaW5nKDAsIGd1ZXNzLmluZGV4KSArXHJcblx0XHRcdFx0XHRndWVzcy5rZXkgK1xyXG5cdFx0XHRcdFx0cHJldmlvdXMuc3Vic3RyaW5nKGd1ZXNzLmluZGV4ICsgMSwgcHJldmlvdXMubGVuZ3RoKVxyXG5cdFx0XHRcdCk7XHJcblx0XHR9LCB3b3JkKTtcclxuXHJcblx0XHQvLyByZXR1cm4gYWx0ZXJlZCBzdHJpbmcgYXMgb3V0cHV0XHJcblx0XHRyZXR1cm4gcmVzdWx0U3RyO1xyXG5cdH07XHJcblxyXG5cdEhBTkdNQU4ucmVwbGFjZSA9IHJlcGxhY2U7XHJcblxyXG5cdC8vIHRha2VzIGluIGEgbnVtYmVyIGluY3JlbWVudHMgaXQgYnkgb25lIGFuZCByZXR1cm5zIHRoZSBpbmNyZW1lbnRlZCBudW1iZXJcclxuXHRjb25zdCBpbmMgPSAobnVtID0gLTEpID0+IG51bSArIDE7XHJcblxyXG5cdEhBTkdNQU4uaW5jID0gaW5jO1xyXG59KShIQU5HTUFOKTtcclxuXHJcbmNvbnN0IGdhbWVXb3JkcyA9IEhBTkdNQU4ud29yZEZhY3RvcnkoXHJcblx0XHRbXHJcblx0XHRcdFsnYm94ZXInLCBcIkl0IGNvdWxkIGJlIGEgbWFuIG9yIGEgZG9nLlwiXSxcclxuXHRcdFx0Wydjb21wbGltZW50JywgXCJTYXkgc29tZXRoaW5nIHRvIG1ha2UgbWUgc21pbGUuXCJdLFxyXG5cdFx0XHRbJ2Jhc2tldGJhbGwnLCAnTm90aGluZyBidXQgbmV0LiddLFxyXG5cdFx0XHRbJ2hpYmVybmF0ZScsICdJIGNhbiBiYXJlIHRoZSBjb2xkLiddLFxyXG5cdFx0XVxyXG5cdCk7XHJcbmNvbnN0IHsgbWFrZUVsZW0sIG1ha2VEYXNoZXMsIGd1ZXNzZXMsIHJlcGxhY2UsIGluYyB9ID0gSEFOR01BTjtcclxuY29uc3QgbWV0aG9kc0FyciA9IFttYWtlRWxlbSwgbWFrZURhc2hlcywgZ3Vlc3NlcywgcmVwbGFjZSwgaW5jXTtcclxuXHJcbmNvbnN0IGdhbWVDb25maWcgPSAod29yZHMsIG1ldGhvZHMpID0+IHtcclxuXHJcbiAgICBjb25zdCB3cmFwUXVlc3RNYXJrID0gKHdvcmQpID0+IHtcclxuICAgICAgICBjb25zdCB3b3JkQXJyID0gWy4uLndvcmRdLm1hcCgobGV0dGVyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChsZXR0ZXIgPT09ICdfJykgcmV0dXJuIGA8c3BhbiBjbGFzcz1cImRpc3BsYXlfX2NvbnRlbnQtLXVuc29sdmVkXCI+JHtsZXR0ZXJ9PC9zcGFuPmA7XHJcbiAgICAgICAgICAgIHJldHVybiBsZXR0ZXI7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHdvcmRBcnIuam9pbignJyk7XHJcbiAgICB9O1xyXG4gICAgXHJcblx0Y29uc3QgW21ha2VFbGVtLCBtYWtlRGFzaGVzLCBndWVzc2VzLCByZXBsYWNlLCBpbmNdID0gbWV0aG9kcztcclxuXHJcblx0Ly8gY3JlYXRlIGFuZCBwbGFjZSBlbGVtZW50cyBpbnRvIERPTSB3aGVuIGdhbWUgaW5pbnRhbGx5IHN0YXJ0c1xyXG5cdGNvbnN0IGdhbWUgPSBtYWtlRWxlbSgpXHJcblx0XHQuYWRkQ2xhc3MoJ2dhbWUnKVxyXG5cdFx0LmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpO1xyXG5cclxuXHRjb25zdCBkaXNwbGF5SGVhZF9fc2NvcmUgPSBtYWtlRWxlbSgpXHJcblx0XHQuYWRkQ2xhc3MoJ2Rpc3BsYXlfX2hlYWRpbmcnKVxyXG5cdFx0LmFkZENsYXNzKCdkaXNwbGF5X19oZWFkaW5nLS1zY29yZScpXHJcblx0XHQuYXBwZW5kVG8oZ2FtZSk7XHJcblxyXG5cdGNvbnN0IGRpc3BsYXlDb250ZW50X193b3JkID0gbWFrZUVsZW0oKVxyXG5cdFx0LmFkZENsYXNzKCdkaXNwbGF5X19jb250ZW50JylcclxuXHRcdC5hZGRDbGFzcygnZGlzcGxheV9fY29udGVudC0td29yZCcpXHJcblx0XHQuYXBwZW5kVG8oZ2FtZSk7XHJcblxyXG5cdGNvbnN0IHdyb25nR3Vlc3Nlc0RpdiA9IG1ha2VFbGVtKClcclxuXHRcdC5hZGRDbGFzcygnd3JvbmctZ3Vlc3NlcycpXHJcblx0XHQuYXBwZW5kVG8oZ2FtZSk7XHJcblx0XHRcclxuXHRjb25zdCBkaXNwbGF5SGVhZF9faGludCA9IG1ha2VFbGVtKClcclxuXHRcdC5hZGRDbGFzcygnZ2FtZV9faGludC1oZWFkJylcclxuXHRcdC5hZGRDbGFzcygnZGlzcGxheV9faGVhZGluZycpXHJcblx0XHQuYWRkQ2xhc3MoJ2Rpc3BsYXlfX2hlYWRpbmctLWhpbnQnKVxyXG5cdFx0LmFwcGVuZFRvKGdhbWUpXHJcblx0XHQudGV4dCgnSGludCcpO1xyXG5cdFx0XHJcblx0Y29uc3QgZGlzcGxheUNvbnRlbnRfX2hpbnQgPSBtYWtlRWxlbSgpXHJcblx0XHQuYWRkQ2xhc3MoJ2Rpc3BsYXlfX2NvbnRlbnQnKVxyXG5cdFx0LmFkZENsYXNzKCdkaXNwbGF5X19jb250ZW50LS1oaW50JylcclxuXHRcdC5odG1sKGBcclxuXHRcdFx0PHAgY2xhc3M9XCJnYW1lLXRleHQgaGludC10ZXh0XCI+JHt3b3Jkc1swXS5oaW50fTwvcD5cclxuXHRcdGApXHJcblx0XHQuYXBwZW5kVG8oZ2FtZSk7IFxyXG5cclxuXHRjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcclxuXHJcblx0Ly8gc2V0IGluaXRpYWwgdmFsdWVzIGZvciBnYW1lXHJcblxyXG5cdGxldCBpbnB1dCA9IFtdO1xyXG5cclxuXHQvLyB0aGlzIHNldHMgdGhlIGNvdW50IHRvIHplcm9cclxuXHQvLyB0aGUgaW5jIGZ1bmN0aW9uIHJldHVybnMgemVybyB3aGVuIGl0IGlzIHBhc3NlZCBubyBhcmd1bWVudHNcclxuXHQvLyBvdGhlcndpc2UgaXQgdGFrZXMgYSBudW1iZXIgYXMgYW4gYXJndW1lbnQgYW5kIHR1cm5zIHRoYXQgbnVtYmVyIGluY3JlbWVudGVkIGJ5IDFcclxuXHQvLyBpbmMoNSkgaXMgNSArIDEsIHdoaWNoIHJldHVybnMgNi5cclxuXHJcblx0bGV0IGNvdW50ID0gaW5jKCk7XHJcblxyXG5cdGxldCB7IHdvcmQgfSA9IHdvcmRzW2NvdW50XTtcclxuXHJcblx0bGV0IHdpbnMgPSAwO1xyXG5cclxuXHRsZXQgY2hhbmNlcyA9IDU7XHJcblxyXG5cdGxldCBndWVzc2VkTGV0dGVycyA9IFtdO1xyXG5cclxuICAgIGxldCBwdXp6bGVXb3JkID0gbWFrZURhc2hlcyh3b3JkKTtcclxuXHJcblx0Ly8gIyMjIyMjIyMjIyMjIFNFVFRJTkcgSU5JVElBTCBET00gRUxFTUVOVFMgIyMjIyMjIyMjIyMjIyMjXHJcblx0bGV0IHdpbnNEaXYgPSBtYWtlRWxlbSgpXHJcblx0XHQuYWRkQ2xhc3MoJ2dhbWVfX3Njb3JlLS13aW5zJylcclxuXHRcdC5odG1sKGB3aW5zOiA8c3BhbiBjbGFzcz1cImdhbWVfX3Njb3JlLS10YWxseVwiPiR7d2luc308L3NwYW4+YClcclxuXHRcdC5hcHBlbmRUbyhkaXNwbGF5SGVhZF9fc2NvcmUpO1xyXG5cdGxldCBjaGFuY2VzRGl2ID0gbWFrZUVsZW0oKVxyXG5cdFx0LmFkZENsYXNzKCdnYW1lX19zY29yZS0tY2hhbmNlcycpXHJcblx0XHQuaHRtbChgY2hhbmNlczogPHNwYW4gY2xhc3M9XCJnYW1lX19zY29yZS0tdGFsbHlcIj4ke2NoYW5jZXN9PC9zcGFuPmApXHJcblx0XHQuYXBwZW5kVG8oZGlzcGxheUhlYWRfX3Njb3JlKTtcclxuXHRcclxuXHRsZXQgd29yZFByb2dyZXNzRGl2ID0gbWFrZUVsZW0oKVxyXG5cdFx0LmFkZENsYXNzKCdnYW1lLXRleHQnKVxyXG5cdFx0LmFkZENsYXNzKCdkaXNwbGF5X19jb250ZW50LS10ZXh0JylcclxuXHRcdC5odG1sKHdyYXBRdWVzdE1hcmsocHV6emxlV29yZCkpXHJcblx0XHQuYXBwZW5kVG8oZGlzcGxheUNvbnRlbnRfX3dvcmQpO1xyXG5cclxuXHRjb25zdCBtb2RhbEJhY2tkcm9wID0gbWFrZUVsZW0oKVxyXG5cdFx0LmFkZENsYXNzKCdtb2RhbF9fYmFja2Ryb3AnKVxyXG5cdFx0LmhpZGUoKVxyXG5cdFx0LmFwcGVuZFRvKGJvZHkpO1xyXG5cdGNvbnN0IG1vZGFsID0gbWFrZUVsZW0oKVxyXG5cdFx0LmFkZENsYXNzKCdtb2RhbCcpXHJcblx0XHQuYXBwZW5kVG8obW9kYWxCYWNrZHJvcCk7XHJcblxyXG5cdGNvbnN0IG1vZGFsTWVzc2FnZSA9IG1ha2VFbGVtKClcclxuXHRcdC5hZGRDbGFzcygnbW9kYWwtLW1lc3NhZ2UnKVxyXG5cdFx0LmFwcGVuZFRvKG1vZGFsKTtcclxuXHJcblx0bGV0IGNhbkluY1Njb3JlcyA9IHRydWU7XHJcblx0bGV0IGFja25vd2xlZGdlR3Vlc3NlcyA9IHRydWU7XHJcblxyXG5cdGNvbnN0IHNvZnRSZXNldCA9ICgpID0+IHtcclxuXHRcdGd1ZXNzZWRMZXR0ZXJzID0gW107XHJcblx0XHRjb3VudCA9IGluYyhjb3VudCk7XHJcblx0XHR3b3JkID0gd29yZHNbY291bnRdLndvcmQ7XHJcblx0XHRwdXp6bGVXb3JkID0gbWFrZURhc2hlcyh3b3JkKTtcclxuXHRcdGlucHV0ID0gW107XHJcblx0XHRjaGFuY2VzID0gNTtcclxuXHRcdHdvcmRQcm9ncmVzc0Rpdi50ZXh0KGBXb3JkIHNvIGZhcjogJHtwdXp6bGVXb3JkfWApO1xyXG5cdFx0Ly8gcHJpbnQgaGludCB0byBzY3JlZW5cclxuXHRcdGRpc3BsYXlDb250ZW50X19oaW50Lmh0bWwoYDxwIGNsYXNzPVwiZ2FtZS10ZXh0IGhpbnQtdGV4dFwiPiR7d29yZHNbY291bnRdLmhpbnR9PC9wPmApXHJcblx0XHRcdFx0LmFkZENsYXNzKCdkaXNwbGF5X19jb250ZW50Jyk7XHJcblxyXG5cdFx0d3JvbmdHdWVzc2VzRGl2LmVtcHR5KCk7XHJcblx0fTtcclxuXHJcblx0Ly8gUkVTVEFSVFMgR0FNRSAtLSBTVEFSVFMgRlJPTSBUSEUgQkVHSU5OSU5HXHJcblx0Y29uc3QgaGFyZFJlc2V0ID0gKCkgPT4ge1xyXG5cdFx0Z3Vlc3NlZExldHRlcnMgPSBbXTtcclxuXHRcdGNhbkluY1Njb3JlcyA9IHRydWU7XHJcblx0XHRjb3VudCA9IGluYygpO1xyXG5cdFx0d29yZCA9IHdvcmRzW2NvdW50XS53b3JkO1xyXG5cdFx0cHV6emxlV29yZCA9IG1ha2VEYXNoZXMod29yZCk7XHJcblx0XHRpbnB1dCA9IFtdO1xyXG5cdFx0Y2hhbmNlcyA9IDU7XHJcblx0XHR3aW5zID0gMDtcclxuXHRcdHdvcmRQcm9ncmVzc0Rpdi5odG1sKHdyYXBRdWVzdE1hcmsocHV6emxlV29yZCkpO1xyXG5cdFx0Ly8gcHJpbnQgaGludCB0byBzY3JlZW5cclxuXHRcdGRpc3BsYXlDb250ZW50X19oaW50Lmh0bWwoYFxyXG5cdFx0XHQ8cCBjbGFzcz1cImdhbWUtdGV4dCBoaW50LXRleHRcIj4ke3dvcmRzW2NvdW50XS5oaW50fTwvcD5cclxuXHRcdGApO1xyXG4gICAgICAgIHdyb25nR3Vlc3Nlc0Rpdi5lbXB0eSgpO1xyXG5cdH07XHJcblxyXG5cdC8vIENPTU1FTkNFIEdBTUUgV0hFTiBVU0VSIFBSRVNTRVMgVEhFIEVOVEVSIEtFWVxyXG5cdGJvZHkub25rZXl1cCA9IGUgPT4ge1xyXG5cdFx0Y29uc3QgaXNBbHBoYWJldCA9IHN0ciA9PiAvXlthLXpBLVooKV0kLy50ZXN0KHN0cik7XHJcblxyXG5cdFx0Ly8gY2FwdHVyZSBrZXkgc3Ryb2tlXHJcblx0XHRsZXQgeyBrZXksIGN0cmxLZXkgfSA9IGU7XHJcblxyXG5cdFx0XHJcblx0XHQvLyBpZiBrZXkgaXMgYSBsZXR0ZXIgdHVybiBpdCB0byBsb3dlciBjYXNlIGFuZCByZWFzc2lnbiBpdCB0byBiYWNrIHRvIGtleVxyXG5cdFx0aWYgKGlzQWxwaGFiZXQoa2V5KSkga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XHJcblx0XHRcclxuXHRcdC8vIG9ubHkgcHJlY2VlZCBpZiBDVFJMIGlzbid0IHByZXNzZWQgYWxvbmcgd2l0aCBhbHBoYWJldCBrZXlcclxuXHRcdGlmIChjdHJsS2V5KSByZXR1cm47XHJcblx0XHRcclxuXHRcdC8vXHJcblx0XHRsZXQgdXNlckd1ZXNzID0gZ3Vlc3Nlcyh3b3JkLCBrZXkpO1xyXG5cclxuXHRcdC8vIHRoaXMgZnVuY3Rpb24gdGVzdHMgdGhlIGtleSBlbnRlcmVkIHRvIGZpbmQgb3V0IGlmIGl0IGlzIGFuIGFscGhhYmV0aWNhbCBjaGFyYWN0ZXJcclxuXHRcdGNvbnN0IGFscGhhYmV0VGVzdFBhc3QgPSBpc0FscGhhYmV0KGtleSk7XHJcblxyXG5cdFx0Ly8gc3ByZWFkIGFycmF5IGFuZCBwdXNoIHRoZW0gaW50byB0aGUgaW5wdXQgYXJyYXlcclxuXHRcdGlmIChhY2tub3dsZWRnZUd1ZXNzZXMpIGlucHV0LnB1c2goLi4udXNlckd1ZXNzKTtcclxuXHJcblx0XHRwdXp6bGVXb3JkID0gcmVwbGFjZShwdXp6bGVXb3JkLCBpbnB1dCk7XHJcblx0XHRcclxuICAgICAgICBcclxuXHRcdC8vICMjIyMjIyMjIyMjIyMjIFVTRVIgR1VFU1NFRCBXUk9ORyAjIyMjIyMjIyMjIyMjXHJcblx0XHRpZiAoXHJcblx0XHRcdCF3b3Jkc1tjb3VudF0uaXNJbmNsdWRlZChrZXkpICYmXHJcblx0XHRcdGNhbkluY1Njb3JlcyA9PT0gdHJ1ZSAmJlxyXG5cdFx0XHRjaGFuY2VzID49IDEgJiZcclxuXHRcdFx0YWxwaGFiZXRUZXN0UGFzdCAmJlxyXG5cdFx0XHQhZ3Vlc3NlZExldHRlcnMuaW5jbHVkZXMoa2V5KVxyXG5cdFx0KSB7XHJcblx0XHRcdGNoYW5jZXMtLTtcclxuXHRcdFx0Z3Vlc3NlZExldHRlcnMucHVzaChrZXkpO1xyXG5cdFx0XHRtYWtlRWxlbSgpXHJcblx0XHRcdFx0LmFkZENsYXNzKCd3cm9uZy1sZXR0ZXInKVxyXG5cdFx0XHRcdC50ZXh0KGtleSlcclxuXHRcdFx0XHQuYXBwZW5kVG8od3JvbmdHdWVzc2VzRGl2KTtcclxuXHRcdFx0XHJcblx0XHRcdHdyb25nR3Vlc3Nlc0RpdlxyXG5cdFx0XHRcdC5hZGRDbGFzcygnd2lnZ2xlLWFuaW1hdGlvbicpO1xyXG5cclxuXHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XHJcblx0XHRcdFx0d3JvbmdHdWVzc2VzRGl2XHJcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCd3aWdnbGUtYW5pbWF0aW9uJyk7XHJcblx0XHRcdH0sIDEwMDApO1xyXG5cdFx0XHRcdFxyXG5cdFx0fVxyXG5cclxuXHRcdC8vICMjIyMjIyMjIyMgVVNFUiBFWEhBVVNUUyBBTEwgSElTIEdVRVNTRVMgIyMjIyMjIyMjIyMjIyNcclxuXHRcdGlmICghY2hhbmNlcykge1xyXG5cdFx0XHRhY2tub3dsZWRnZUd1ZXNzZXMgPSBmYWxzZTtcclxuXHRcdFx0Ly8gYWxlcnQoJ1lvdSBsb3N0IScpO1xyXG5cdFx0XHQvLyBjb3VudCA9IGluYygpO1xyXG5cdFx0XHRtb2RhbE1lc3NhZ2UuaHRtbChgPHNwYW4gY2xhc3M9XCJtb2RhbF9faGVhZGluZy0tbG9zc1wiPllvdSBsb3NlITwvc3Bhbj4gXHJcbiAgICAgICAgICAgIDxicj4gXHJcbiAgICAgICAgICAgIFRoZSB3b3JkIHdhcyA8c3BhbiBjbGFzcz1cIm1vZGFsX19ub3RhYmxlLS1sb3NzXCI+XCIke3dvcmRzW2NvdW50XS53b3JkfVwiPC9zcGFuPlxyXG4gICAgICAgICAgICA8YnI+XHJcbiAgICAgICAgICAgIFByZXNzIDxzcGFuIGNsYXNzPVwibW9kYWxfX25vdGFibGUtLWxvc3NcIj5cIkVudGVyXCI8L3NwYW4+IHRvIHN0YXJ0IG92ZXIuYCk7XHJcblx0XHRcdG1vZGFsQmFja2Ryb3Auc2hvdygpO1xyXG5cdFx0XHRpZiAoa2V5ID09PSAnRW50ZXInKSB7XHJcblx0XHRcdFx0Y291bnQgPSBpbmMoKTtcclxuXHRcdFx0XHR3aW5zID0gaW5jKCk7XHJcblx0XHRcdFx0bW9kYWxCYWNrZHJvcC5oaWRlKCk7XHJcblx0XHRcdFx0d3JvbmdHdWVzc2VzRGl2LmVtcHR5KCk7XHJcblx0XHRcdFx0YWNrbm93bGVkZ2VHdWVzc2VzID0gdHJ1ZTtcclxuXHRcdFx0XHR3b3JkID0gd29yZHNbY291bnRdLndvcmQ7XHJcblx0XHRcdFx0cHV6emxlV29yZCA9IG1ha2VEYXNoZXMod29yZCk7XHJcblx0XHRcdFx0aW5wdXQgPSBbXTtcclxuXHRcdFx0XHRjaGFuY2VzID0gNTtcclxuXHRcdFx0XHR3b3JkUHJvZ3Jlc3NEaXYuaHRtbCh3cmFwUXVlc3RNYXJrKHB1enpsZVdvcmQpKTtcclxuXHRcdFx0XHQvLyBwcmludCBoaW50IHRvIHNjcmVlblxyXG5cdFx0XHRcdGRpc3BsYXlDb250ZW50X19oaW50Lmh0bWwoYFxyXG5cdFx0XHRcdFx0PHAgY2xhc3M9XCJnYW1lLXRleHQgaGludC10ZXh0XCI+JHt3b3Jkc1tjb3VudF0uaGludH08L3A+XHJcblx0XHRcdFx0YCk7XHJcblx0XHRcdFx0d2luc0Rpdi5odG1sKGB3aW5zOiA8c3BhbiBjbGFzcz1cImdhbWVfX3Njb3JlLS10YWxseVwiPiR7d2luc308L3NwYW4+YCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBwcmludCBoaW50IHRvIHNjcmVlblxyXG5cdFx0ZGlzcGxheUNvbnRlbnRfX2hpbnQuaHRtbChgXHJcblx0XHRcdDxwIGNsYXNzPVwiZ2FtZS10ZXh0IGhpbnQtdGV4dFwiPiR7d29yZHNbY291bnRdLmhpbnR9PC9wPlxyXG5cdFx0YCk7XHJcblx0XHRcclxuXHRcdC8vICMjIyMjIyMjIyMjIyMjIyMgVVNFUiBHT1QgQUxMIFRIRSBMRVRURVJTICMjIyMjIyMjIyMjIyMjI1xyXG5cdFx0aWYgKHdvcmRzW2NvdW50XS5pc01hdGNoZWQocHV6emxlV29yZCkpIHtcclxuXHRcdFx0aWYgKGNhbkluY1Njb3Jlcykgd2lucysrO1xyXG5cdFx0XHRjYW5JbmNTY29yZXMgPSBmYWxzZTtcclxuXHRcdFx0d2luc0Rpdi5odG1sKGB3aW5zOiA8c3BhbiBjbGFzcz1cImdhbWVfX3Njb3JlLS10YWxseVwiPiR7d2luc308L3NwYW4+YCk7XHJcblx0XHRcdHdvcmRQcm9ncmVzc0Rpdi50ZXh0KGBXb3JkIHNvIGZhcjogJHtwdXp6bGVXb3JkfWApO1xyXG5cdFx0XHQvLyBwcmludCBoaW50IHRvIHNjcmVlblxyXG5cdFx0XHRkaXNwbGF5Q29udGVudF9faGludC5odG1sKGBcclxuXHRcdFx0XHQ8cCBjbGFzcz1cImdhbWUtdGV4dCBoaW50LXRleHRcIj4ke3dvcmRzW2NvdW50XS5oaW50fTwvcD5cclxuXHRcdFx0YCk7XHJcblx0XHRcdC8vIG1vZGFsV29yZERpc3BsYXkudGV4dChwdXp6bGVXb3JkKTtcclxuXHRcdFx0bW9kYWxNZXNzYWdlLmh0bWwoYDxoMiBjbGFzcz1cIm1vZGFsX19oZWFkaW5nLS13aW5cIj5Db25ncmF0dWxhdGlvbnMhPC9oMj4gXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwibW9kYWxfX25vdGFibGVcIj5Zb3UncmUgY29ycmVjdC4gVGhlIHdvcmQncyA8c3BhbiBjbGFzcz1cIm1vZGFsX19ub3RhYmxlLS13aW5cIj5cIiR7cHV6emxlV29yZH1cIjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIFByZXNzIDxzcGFuIGNsYXNzPVwibW9kYWxfX25vdGFibGUtLXdpblwiPlwiRW50ZXJcIjwvc3Bhbj4gdG8gYXR0ZW1wdCB0aGUgbmV4dCB3b3JkLjwvcD5gKTtcclxuXHRcdFx0bW9kYWxCYWNrZHJvcC5zaG93KCk7XHJcblxyXG4gICAgICAgICAgICAvLyAgcGxheWVyIGNvbXBsZXRlZCBldmVyeSB3b3JkIC0tLS0tVE9ETy0tLS0tXHJcbiAgICAgICAgICAgIGlmICh3aW5zID09PSB3b3Jkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIG1vZGFsTWVzc2FnZS5odG1sKGBcclxuICAgICAgICAgICAgICAgICAgICA8aDEgY2xhc3M9XCJtb2RhbF9faGVhZGluZy0td2luXCI+Q29uZ3JhdHVsYXRpb25zPC9oMT5cclxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cIm1vZGFsLS1tZXNzYWdlXCI+WW91J3ZlIGZvdW5kIGFsbCB0aGUgd29yZHMuIFByZXNzIEVudGVyIHRvIG92ZXI8L3A+XHJcbiAgICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcblx0XHRcdC8vIG1vdmUgdG8gbmV4dCB3b3JkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBlbnRlclxyXG5cdFx0XHRpZiAoa2V5ID09PSAnRW50ZXInKSB7XHJcblx0XHRcdFx0Y2FuSW5jU2NvcmVzID0gdHJ1ZTtcclxuXHRcdFx0XHQvLyAjIyMjIyMgVVNFUiBHT1QgQUxMIFRIRSBXT1JEUyAjIyMjIyMjI1xyXG5cdFx0XHRcdGlmICh3b3Jkc1tjb3VudF0gIT09IHdvcmRzW3dvcmRzLmxlbmd0aCAtIDFdKSB7XHJcblx0XHRcdFx0XHQvLyAgdG8gbmV4dCB3b3JkIGFuZCByZXNldCBuZWdhdGl2ZSByZWNvcmQgcmVnYXJkaW5nIGVhdCBpbmRpdmlkdWFsIHdvcmRcclxuXHRcdFx0XHRcdHNvZnRSZXNldCgpO1xyXG5cdFx0XHRcdFx0bW9kYWxCYWNrZHJvcC5oaWRlKCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIHRoZSBnYW1lIHJlc2V0cyB3aGVuIGFsbCB0aGUgd29yZHMgaGF2ZSBiZWVuIHNvbHZlZFxyXG5cdFx0XHRcdFx0aGFyZFJlc2V0KCk7XHJcblx0XHRcdFx0XHRtb2RhbEJhY2tkcm9wLmhpZGUoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcbiAgICAgICAgY2hhbmNlc0Rpdi5odG1sKGBjaGFuY2VzOiA8c3BhbiBjbGFzcz1cImdhbWVfX3Njb3JlLS10YWxseVwiPiR7Y2hhbmNlc308L3NwYW4+YCk7XHJcbiAgICAgICAgd2luc0Rpdi5odG1sKGB3aW5zOiA8c3BhbiBjbGFzcz1cImdhbWVfX3Njb3JlLS10YWxseVwiPiR7d2luc308L3NwYW4+YCk7XHJcblx0XHR3b3JkUHJvZ3Jlc3NEaXYuaHRtbCh3cmFwUXVlc3RNYXJrKHB1enpsZVdvcmQpKTtcclxuXHR9O1xyXG59O1xyXG5cclxuLy8gPT09PT09PT09PT09PT09PT09PSBFVkVOVCBIQU5ETEVSIEZPUiBTVEFSVElORyBHQU1FPT09PT09PT09PT09PT09PT09PT09PT1cclxuY29uc3QgaGFuZGxlS2V5cHJlc3MgPSBlID0+IHtcclxuXHRjb25zdCB7IGtleSwgdGFyZ2V0IH0gPSBlO1xyXG5cclxuXHRjb25zdCBpbnRybyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbnRybycpO1xyXG5cclxuXHRpZiAoa2V5ID09PSAnRW50ZXInKSB7XHJcblx0XHRnYW1lQ29uZmlnKGdhbWVXb3JkcywgbWV0aG9kc0Fycik7XHJcblx0XHRpbnRyby5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGludHJvKTtcclxuXHRcdFxyXG5cdFx0Ly8gcmVtb3ZlIGxpc3RlbmVyIHNvIHRoYXQgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IHJ1biBvbmNlLCB3aGVuIHRoZSB1c2VyIGluaXRpYWxseSBjb21lcyB0byB0aGUgc2l0ZVxyXG5cdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgaGFuZGxlS2V5cHJlc3MpO1xyXG5cdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlS2V5cHJlc3MpO1xyXG5cdH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGhhbmRsZUNsaWNrIChlKSB7XHJcblx0Y29uc3Qge3RhcmdldH0gPSBlO1xyXG5cdFxyXG5cdGNvbnN0IGludHJvID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmludHJvJyk7XHJcblx0XHJcblx0aW50cm8ucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChpbnRybyk7XHJcblx0Z2FtZUNvbmZpZyhnYW1lV29yZHMsIG1ldGhvZHNBcnIpO1xyXG5cclxuXHR0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGljayk7XHJcblx0ZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGhhbmRsZUtleXByZXNzKTtcclxufVxyXG5cclxuZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGhhbmRsZUtleXByZXNzKTtcclxuY29uc3QgaW50cm9UZXh0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmludHJvLS10ZXh0Jyk7XHJcbmludHJvVGV4dC5vbmNsaWNrID0gaGFuZGxlQ2xpY2s7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvYXBwLmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTtBQUNBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQU1BO0FBSUE7QUFKQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBSUE7QUFDQTtBQUtBO0FBSUE7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zdHlsZS9tYWluLnNjc3M/NDYwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3N0eWxlL21haW4uc2Nzc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ })
/******/ ]);