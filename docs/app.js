/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__style_main_scss__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__style_main_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__style_main_scss__);\n// import styles\n\n\nconst HANGMAN = {};\n\n// -------------------------NAMESPACE -------------------------\n(namespace => {\n  // -----------------------WORD CLASS------------------------\n  // used to make words for game\n  class Word {\n    constructor(word, hint) {\n      this.word = word.toLowerCase();\n      this.hint = hint;\n      this.isMatched = this.isMatched.bind(this);\n      this.isIncluded = this.isIncluded.bind(this);\n    }\n\n    // method to test if user letter choice is present in word\n    isIncluded(char) {\n      return this.word.includes(char.toLowerCase().trim());\n    }\n\n    // method to test if word is correct\n    isMatched(letters) {\n      return this.word === letters.toLowerCase().trim();\n    }\n  }\n\n  // ----------------------WORD FACTORY------------------------\n  // make single word or an array of words and make it a property of HANGMAN\n  // it takes an a single string, multiple stings, or an array of stings as an argument\n  namespace.wordFactory = (...word) => {\n    // if argument is an array make it an array by destructuring it\n    if (Array.isArray(...word)) [word] = word;\n    // iterate through an array of strings and return an array of objects\n    if (word.length > 1) return word.map(item => new Word(...item));\n\n    // if argument is a single string destructure the array and output a string\n    const [singleWord] = word;\n    // make a single object\n    return new Word(singleWord);\n  };\n\n  // ------------------ARRAY ITERATOR ----------------------------------\n\n  // loop through array of words and execute callback function using recursive function\n  const arrayIterator = (wordList, cb) => {\n    const [a, ...b] = wordList;\n    cb(a);\n    if (wordList.length === 1) return;\n    arrayIterator(b, cb);\n  };\n\n  namespace.arrayIterator = arrayIterator;\n\n  // This method takes in a string and outputs a string of underscores\n  // proportionate to the number of characters contained in the string\n  const makeDashes = answer => {\n    const dashed = [];\n    (function looper(answer) {\n      const [a, ...b] = [...answer];\n\n      dashed.push('_');\n      if (answer.length === 1) return;\n      looper(b);\n    })(answer);\n    return dashed.join('');\n  };\n\n  namespace.makeDashes = makeDashes;\n\n  // this is a method used for DOM manipulation\n  // the names of the functions within it borrow from jQuery\n  const makeElem = (elemName = 'div') => {\n    const elem = global.document.createElement(elemName);\n\n    // insert element into another element\n    elem.appendTo = parent => {\n      parent.appendChild(elem);\n      return elem;\n    };\n\n    // add text to element\n    elem.text = text => {\n      elem.textContent = text;\n      return elem;\n    };\n\n    // add HTML to element\n    elem.html = html => {\n      elem.innerHTML = html;\n      return elem;\n    };\n\n    // empty the element of all it's content\n    elem.empty = () => {\n      elem.innerHTML = '';\n      return elem;\n    };\n\n    // hide the element\n    elem.hide = () => {\n      elem.style.visibility = 'hidden';\n      return elem;\n    };\n\n    // show element\n    elem.show = () => {\n      elem.style.visibility = 'visible';\n      return elem;\n    };\n\n    // add CSS class to element\n    elem.addClass = className => {\n      elem.classList.add(className);\n      return elem;\n    };\n\n    // remove CSS class from element\n    elem.removeClass = className => {\n      elem.classList.remove(className);\n      return elem;\n    };\n\n    return elem;\n  };\n\n  namespace.makeElem = makeElem;\n\n  // this takes in two arguments, the answer and the user's guess\n  // if the letter guess is present in the answer it outputs an array of objects with the\n  // letter as a string and the index at which the letter is present in the answer string\n  const guesses = (answer, letterGuessed) =>\n  // spread the characters in the string and place them in an array\n  // then iterate through them using the reduce function which returns a array that contains\n  // all the letter guessed and the the index at which it is matched in the answers string\n  [...answer].reduce((arr, letter, index) => {\n    if (letterGuessed === letter) {\n      const obj = {\n        key: letterGuessed,\n        index\n      };\n      arr.push(obj);\n    }\n    return arr;\n  }, []);\n\n  namespace.guesses = guesses;\n\n  // replaces characters in a string where with provided replacement character\n  // and index where it should be placed\n  // it receives two arguments, a string and an array of objects containing\n  // a character the user guessed and it's index in the answer\n  // all characters provided are contained in the answer\n  const replace = (word, input) => {\n    const resultStr = input.reduce((previous, guess) => {\n      // insert each letter according to it's provided index\n      if (guess.index !== -1) {\n        return previous.substring(0, guess.index) + guess.key + previous.substring(guess.index + 1, previous.length);\n      }\n    }, word);\n\n    // return altered string as output\n    return resultStr;\n  };\n\n  namespace.replace = replace;\n\n  // takes in a number increments it by one and returns the incremented number\n  const inc = (num = -1) => num + 1;\n\n  namespace.inc = inc;\n})(HANGMAN);\n\nconst gameWords = HANGMAN.wordFactory([['boxer', 'It could be a man or a dog.'], ['compliment', 'Say something to make me smile.'], ['basketball', 'Nothing but net.'], ['hibernate', 'I can bare the cold.']]);\nconst {\n  makeElem, makeDashes, guesses, replace, inc\n} = HANGMAN;\nconst methodsArr = [makeElem, makeDashes, guesses, replace, inc];\n\nconst gameConfig = (words, methods) => {\n  const [makeElem, makeDashes, guesses, replace, inc] = methods;\n\n  // create and place elements into DOM when game inintally starts\n  const game = makeElem().addClass('game').appendTo(global.document.body);\n\n  const displayHeadScore = makeElem().addClass('display__heading').addClass('display__heading--score').appendTo(game);\n\n  const displayContentWord = makeElem().addClass('display__content').addClass('display__content--word').appendTo(game);\n\n  const wrongGuessesDiv = makeElem().addClass('wrong-guesses').appendTo(game);\n\n  const displayHeadHint = makeElem();\n\n  displayHeadHint.addClass('game__hint-head').addClass('display__heading').addClass('display__heading--hint').appendTo(game).text('Hint');\n\n  const displayContentHint = makeElem().addClass('display__content').addClass('display__content--hint').html(`<p class=\"game-text hint-text\">${words[0].hint}</p>`).appendTo(game);\n\n  const { body } = global.document;\n\n  // set initial values for game\n\n  let input = [];\n\n  // this sets the count to zero\n  // the inc function returns zero when it is passed no arguments\n  // otherwise it takes a number as an argument and turns that number incremented by 1\n  // inc(5) is 5 + 1, which returns 6.\n\n  let count = inc();\n\n  let { word } = words[count];\n\n  let wins = 0;\n\n  let chances = 5;\n\n  let guessedLetters = [];\n\n  let puzzleWord = makeDashes(word);\n\n  // ############ SETTING INITIAL DOM ELEMENTS ###############\n  const winsDiv = makeElem().addClass('game__score--wins').html(`wins: <span class=\"game__score--tally\">${wins}</span>`).appendTo(displayHeadScore);\n  const chancesDiv = makeElem().addClass('game__score--chances').html(`chances: <span class=\"game__score--tally\">${chances}</span>`).appendTo(displayHeadScore);\n\n  const wordProgressDiv = makeElem().addClass('game-text').addClass('display__content--text').html(puzzleWord).appendTo(displayContentWord);\n\n  const modalBackdrop = makeElem().addClass('modal__backdrop').hide().appendTo(body);\n  const modal = makeElem().addClass('modal').appendTo(modalBackdrop);\n\n  const modalMessage = makeElem().addClass('modal--message').appendTo(modal);\n\n  let canIncScores = true;\n  let acknowledgeGuesses = true;\n\n  const softReset = () => {\n    guessedLetters = [];\n    count = inc(count);\n    word = words[count].word;\n    puzzleWord = makeDashes(word);\n    input = [];\n    chances = 5;\n    wordProgressDiv.text(`Word so far: ${puzzleWord}`);\n    // print hint to screen\n    displayContentHint.html(`<p class=\"game-text hint-text\">${words[count].hint}</p>`).addClass('display__content');\n\n    wrongGuessesDiv.empty();\n  };\n\n  // RESTARTS GAME -- STARTS FROM THE BEGINNING\n  const hardReset = () => {\n    guessedLetters = [];\n    canIncScores = true;\n    count = inc();\n    word = words[count].word;\n    puzzleWord = makeDashes(word);\n    input = [];\n    chances = 5;\n    wins = 0;\n    wordProgressDiv.html(puzzleWord);\n    // print hint to screen\n    displayContentHint.html(`<p class=\"game-text hint-text\">${words[count].hint}</p>`);\n    wrongGuessesDiv.empty();\n  };\n\n  // COMMENCE GAME WHEN USER PRESSES THE ENTER KEY\n  body.onkeyup = e => {\n    const isAlphabet = str => /^[a-zA-Z()]$/.test(str);\n\n    // capture key stroke\n    let { key, ctrlKey } = e;\n\n    // if key is a letter turn it to lower case and reassign it to back to key\n    if (isAlphabet(key)) key = key.toLowerCase();\n\n    // only precede if CTRL isn't pressed along with alphabet key\n    if (ctrlKey) return;\n\n    //\n    const userGuess = guesses(word, key);\n\n    // this function tests the key entered to find out if it is an alphabetical character\n    const alphabetTestPast = isAlphabet(key);\n\n    // spread array and push them into the input array\n    if (acknowledgeGuesses) input.push(...userGuess);\n\n    puzzleWord = replace(puzzleWord, input);\n\n    // ############## USER GUESSED WRONG #############\n    if (!words[count].isIncluded(key) && canIncScores === true && chances >= 1 && alphabetTestPast && !guessedLetters.includes(key)) {\n      chances--;\n      guessedLetters.push(key);\n      makeElem().addClass('wrong-letter').text(key).appendTo(wrongGuessesDiv);\n\n      wrongGuessesDiv.addClass('wiggle-animation');\n\n      setTimeout(() => {\n        wrongGuessesDiv.removeClass('wiggle-animation');\n      }, 1000);\n    }\n\n    // ########## USER EXHAUSTS ALL HIS GUESSES ##############\n    if (!chances) {\n      acknowledgeGuesses = false;\n      // alert('You lost!');\n      // count = inc();\n      modalMessage.html(`<span class=\"modal__heading--loss\">You lose!</span> \n            <br> \n            The word was <span class=\"modal__notable--loss\">\"${words[count].word}\"</span>\n            <br>\n            Press <span class=\"modal__notable--loss\">\"Enter\"</span> to start over.`);\n      modalBackdrop.show();\n      if (key === 'Enter') {\n        count = inc();\n        wins = inc();\n        modalBackdrop.hide();\n        wrongGuessesDiv.empty();\n        acknowledgeGuesses = true;\n        word = words[count].word;\n        puzzleWord = makeDashes(word);\n        input = [];\n        chances = 5;\n        wordProgressDiv.html(puzzleWord);\n        // print hint to screen\n        displayContentHint.html(`<p class=\"game-text hint-text\">${words[count].hint}</p>`);\n        winsDiv.html(`wins: <span class=\"game__score--tally\">${wins}</span>`);\n      }\n    }\n\n    // print hint to screen\n    displayContentHint.html(`<p class=\"game-text hint-text\">${words[count].hint}</p>`);\n\n    // ################ USER GOT ALL THE LETTERS ###############\n    if (words[count].isMatched(puzzleWord)) {\n      if (canIncScores) wins++;\n      canIncScores = false;\n      winsDiv.html(`wins: <span class=\"game__score--tally\">${wins}</span>`);\n      wordProgressDiv.text(`Word so far: ${puzzleWord}`);\n      // print hint to screen\n      displayContentHint.html(`<p class=\"game-text hint-text\">${words[count].hint}</p>`);\n      // modalWordDisplay.text(puzzleWord);\n      modalMessage.html(`<h2 class=\"modal__heading--win\">Congratulations!</h2> \n                \n                <p class=\"modal__notable\">You're correct. The word's <span class=\"modal__notable--win\">\"${puzzleWord}\"</span>\n                Press <span class=\"modal__notable--win\">\"Enter\"</span> to attempt the next word.</p>`);\n      modalBackdrop.show();\n\n      //  player completed every word -----TODO-----\n      if (wins === words.length) {\n        modalMessage.html(`\n                    <h1 class=\"modal__heading--win\">Congratulations</h1>\n                    <p class=\"modal--message\">You've found all the words. Press Enter to over</p>\n                 `);\n      }\n\n      // move to next word when the user presses enter\n      if (key === 'Enter') {\n        canIncScores = true;\n        // ###### USER GOT ALL THE WORDS ########\n        if (words[count] !== words[words.length - 1]) {\n          //  to next word and reset negative record regarding eat individual word\n          softReset();\n          modalBackdrop.hide();\n        } else {\n          // the game resets when all the words have been solved\n          hardReset();\n          modalBackdrop.hide();\n        }\n      }\n    }\n\n    chancesDiv.html(`chances: <span class=\"game__score--tally\">${chances}</span>`);\n    winsDiv.html(`wins: <span class=\"game__score--tally\">${wins}</span>`);\n    wordProgressDiv.html(puzzleWord);\n  };\n};\n\n// =================== EVENT HANDLER FOR STARTING GAME=======================\nconst handleKeypress = e => {\n  const { key, target } = e;\n\n  const intro = global.document.querySelector('.intro');\n\n  if (key === 'Enter') {\n    gameConfig(gameWords, methodsArr);\n    intro.parentElement.removeChild(intro);\n\n    // remove listener so that this function is only run once...\n    // when the user initially comes to the site\n    target.removeEventListener('keypress', handleKeypress);\n    target.removeEventListener('click', handleKeypress);\n  }\n};\n\nfunction handleClick(e) {\n  const { target } = e;\n\n  const intro = global.document.querySelector('.intro');\n\n  intro.parentElement.removeChild(intro);\n  gameConfig(gameWords, methodsArr);\n\n  target.removeEventListener('click', handleClick);\n  global.document.body.removeEventListener('keypress', handleKeypress);\n}\n\nglobal.document.body.addEventListener('keypress', handleKeypress);\nconst introText = global.document.querySelector('.intro--text');\nintroText.onclick = handleClick;\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(1)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvYXBwLmpzP2JkOWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaW1wb3J0IHN0eWxlc1xuaW1wb3J0ICcuL3N0eWxlL21haW4uc2Nzcyc7XG5cbmNvbnN0IEhBTkdNQU4gPSB7fTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLU5BTUVTUEFDRSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4oKG5hbWVzcGFjZSkgPT4ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVdPUkQgQ0xBU1MtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gdXNlZCB0byBtYWtlIHdvcmRzIGZvciBnYW1lXG4gIGNsYXNzIFdvcmQge1xuICAgIGNvbnN0cnVjdG9yKHdvcmQsIGhpbnQpIHtcbiAgICAgIHRoaXMud29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRoaXMuaGludCA9IGhpbnQ7XG4gICAgICB0aGlzLmlzTWF0Y2hlZCA9IHRoaXMuaXNNYXRjaGVkLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmlzSW5jbHVkZWQgPSB0aGlzLmlzSW5jbHVkZWQuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBtZXRob2QgdG8gdGVzdCBpZiB1c2VyIGxldHRlciBjaG9pY2UgaXMgcHJlc2VudCBpbiB3b3JkXG4gICAgaXNJbmNsdWRlZChjaGFyKSB7XG4gICAgICByZXR1cm4gdGhpcy53b3JkLmluY2x1ZGVzKGNoYXIudG9Mb3dlckNhc2UoKS50cmltKCkpO1xuICAgIH1cblxuICAgIC8vIG1ldGhvZCB0byB0ZXN0IGlmIHdvcmQgaXMgY29ycmVjdFxuICAgIGlzTWF0Y2hlZChsZXR0ZXJzKSB7XG4gICAgICByZXR1cm4gdGhpcy53b3JkID09PSBsZXR0ZXJzLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1XT1JEIEZBQ1RPUlktLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gbWFrZSBzaW5nbGUgd29yZCBvciBhbiBhcnJheSBvZiB3b3JkcyBhbmQgbWFrZSBpdCBhIHByb3BlcnR5IG9mIEhBTkdNQU5cbiAgLy8gaXQgdGFrZXMgYW4gYSBzaW5nbGUgc3RyaW5nLCBtdWx0aXBsZSBzdGluZ3MsIG9yIGFuIGFycmF5IG9mIHN0aW5ncyBhcyBhbiBhcmd1bWVudFxuICBuYW1lc3BhY2Uud29yZEZhY3RvcnkgPSAoLi4ud29yZCkgPT4ge1xuICAgIC8vIGlmIGFyZ3VtZW50IGlzIGFuIGFycmF5IG1ha2UgaXQgYW4gYXJyYXkgYnkgZGVzdHJ1Y3R1cmluZyBpdFxuICAgIGlmIChBcnJheS5pc0FycmF5KC4uLndvcmQpKSBbd29yZF0gPSB3b3JkO1xuICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCByZXR1cm4gYW4gYXJyYXkgb2Ygb2JqZWN0c1xuICAgIGlmICh3b3JkLmxlbmd0aCA+IDEpIHJldHVybiB3b3JkLm1hcChpdGVtID0+IG5ldyBXb3JkKC4uLml0ZW0pKTtcblxuICAgIC8vIGlmIGFyZ3VtZW50IGlzIGEgc2luZ2xlIHN0cmluZyBkZXN0cnVjdHVyZSB0aGUgYXJyYXkgYW5kIG91dHB1dCBhIHN0cmluZ1xuICAgIGNvbnN0IFtzaW5nbGVXb3JkXSA9IHdvcmQ7XG4gICAgLy8gbWFrZSBhIHNpbmdsZSBvYmplY3RcbiAgICByZXR1cm4gbmV3IFdvcmQoc2luZ2xlV29yZCk7XG4gIH07XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tQVJSQVkgSVRFUkFUT1IgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIGxvb3AgdGhyb3VnaCBhcnJheSBvZiB3b3JkcyBhbmQgZXhlY3V0ZSBjYWxsYmFjayBmdW5jdGlvbiB1c2luZyByZWN1cnNpdmUgZnVuY3Rpb25cbiAgY29uc3QgYXJyYXlJdGVyYXRvciA9ICh3b3JkTGlzdCwgY2IpID0+IHtcbiAgICBjb25zdCBbYSwgLi4uYl0gPSB3b3JkTGlzdDtcbiAgICBjYihhKTtcbiAgICBpZiAod29yZExpc3QubGVuZ3RoID09PSAxKSByZXR1cm47XG4gICAgYXJyYXlJdGVyYXRvcihiLCBjYik7XG4gIH07XG5cbiAgbmFtZXNwYWNlLmFycmF5SXRlcmF0b3IgPSBhcnJheUl0ZXJhdG9yO1xuXG4gIC8vIFRoaXMgbWV0aG9kIHRha2VzIGluIGEgc3RyaW5nIGFuZCBvdXRwdXRzIGEgc3RyaW5nIG9mIHVuZGVyc2NvcmVzXG4gIC8vIHByb3BvcnRpb25hdGUgdG8gdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbnRhaW5lZCBpbiB0aGUgc3RyaW5nXG4gIGNvbnN0IG1ha2VEYXNoZXMgPSAoYW5zd2VyKSA9PiB7XG4gICAgY29uc3QgZGFzaGVkID0gW107XG4gICAgKGZ1bmN0aW9uIGxvb3BlcihhbnN3ZXIpIHtcbiAgICAgIGNvbnN0IFthLCAuLi5iXSA9IFsuLi5hbnN3ZXJdO1xuXG4gICAgICBkYXNoZWQucHVzaCgnXycpO1xuICAgICAgaWYgKGFuc3dlci5sZW5ndGggPT09IDEpIHJldHVybjtcbiAgICAgIGxvb3BlcihiKTtcbiAgICB9KGFuc3dlcikpO1xuICAgIHJldHVybiBkYXNoZWQuam9pbignJyk7XG4gIH07XG5cbiAgbmFtZXNwYWNlLm1ha2VEYXNoZXMgPSBtYWtlRGFzaGVzO1xuXG4gIC8vIHRoaXMgaXMgYSBtZXRob2QgdXNlZCBmb3IgRE9NIG1hbmlwdWxhdGlvblxuICAvLyB0aGUgbmFtZXMgb2YgdGhlIGZ1bmN0aW9ucyB3aXRoaW4gaXQgYm9ycm93IGZyb20galF1ZXJ5XG4gIGNvbnN0IG1ha2VFbGVtID0gKGVsZW1OYW1lID0gJ2RpdicpID0+IHtcbiAgICBjb25zdCBlbGVtID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoKGVsZW1OYW1lKSk7XG5cbiAgICAvLyBpbnNlcnQgZWxlbWVudCBpbnRvIGFub3RoZXIgZWxlbWVudFxuICAgIGVsZW0uYXBwZW5kVG8gPSAocGFyZW50KSA9PiB7XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbSk7XG4gICAgICByZXR1cm4gZWxlbTtcbiAgICB9O1xuXG4gICAgLy8gYWRkIHRleHQgdG8gZWxlbWVudFxuICAgIGVsZW0udGV4dCA9ICh0ZXh0KSA9PiB7XG4gICAgICBlbGVtLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgIHJldHVybiBlbGVtO1xuICAgIH07XG5cbiAgICAvLyBhZGQgSFRNTCB0byBlbGVtZW50XG4gICAgZWxlbS5odG1sID0gKGh0bWwpID0+IHtcbiAgICAgIGVsZW0uaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIHJldHVybiBlbGVtO1xuICAgIH07XG5cbiAgICAvLyBlbXB0eSB0aGUgZWxlbWVudCBvZiBhbGwgaXQncyBjb250ZW50XG4gICAgZWxlbS5lbXB0eSA9ICgpID0+IHtcbiAgICAgIGVsZW0uaW5uZXJIVE1MID0gJyc7XG4gICAgICByZXR1cm4gZWxlbTtcbiAgICB9O1xuXG4gICAgLy8gaGlkZSB0aGUgZWxlbWVudFxuICAgIGVsZW0uaGlkZSA9ICgpID0+IHtcbiAgICAgIGVsZW0uc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgcmV0dXJuIGVsZW07XG4gICAgfTtcblxuICAgIC8vIHNob3cgZWxlbWVudFxuICAgIGVsZW0uc2hvdyA9ICgpID0+IHtcbiAgICAgIGVsZW0uc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgIHJldHVybiBlbGVtO1xuICAgIH07XG5cbiAgICAvLyBhZGQgQ1NTIGNsYXNzIHRvIGVsZW1lbnRcbiAgICBlbGVtLmFkZENsYXNzID0gKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgZWxlbS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICByZXR1cm4gZWxlbTtcbiAgICB9O1xuXG4gICAgLy8gcmVtb3ZlIENTUyBjbGFzcyBmcm9tIGVsZW1lbnRcbiAgICBlbGVtLnJlbW92ZUNsYXNzID0gKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgZWxlbS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICByZXR1cm4gZWxlbTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGVsZW07XG4gIH07XG5cbiAgbmFtZXNwYWNlLm1ha2VFbGVtID0gbWFrZUVsZW07XG5cbiAgLy8gdGhpcyB0YWtlcyBpbiB0d28gYXJndW1lbnRzLCB0aGUgYW5zd2VyIGFuZCB0aGUgdXNlcidzIGd1ZXNzXG4gIC8vIGlmIHRoZSBsZXR0ZXIgZ3Vlc3MgaXMgcHJlc2VudCBpbiB0aGUgYW5zd2VyIGl0IG91dHB1dHMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHRoZVxuICAvLyBsZXR0ZXIgYXMgYSBzdHJpbmcgYW5kIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgbGV0dGVyIGlzIHByZXNlbnQgaW4gdGhlIGFuc3dlciBzdHJpbmdcbiAgY29uc3QgZ3Vlc3NlcyA9IChhbnN3ZXIsIGxldHRlckd1ZXNzZWQpID0+IChcbiAgICAvLyBzcHJlYWQgdGhlIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZyBhbmQgcGxhY2UgdGhlbSBpbiBhbiBhcnJheVxuICAgIC8vIHRoZW4gaXRlcmF0ZSB0aHJvdWdoIHRoZW0gdXNpbmcgdGhlIHJlZHVjZSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgYXJyYXkgdGhhdCBjb250YWluc1xuICAgIC8vIGFsbCB0aGUgbGV0dGVyIGd1ZXNzZWQgYW5kIHRoZSB0aGUgaW5kZXggYXQgd2hpY2ggaXQgaXMgbWF0Y2hlZCBpbiB0aGUgYW5zd2VycyBzdHJpbmdcbiAgICBbLi4uYW5zd2VyXS5yZWR1Y2UoKGFyciwgbGV0dGVyLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGxldHRlckd1ZXNzZWQgPT09IGxldHRlcikge1xuICAgICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgICAga2V5OiBsZXR0ZXJHdWVzc2VkLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICB9O1xuICAgICAgICBhcnIucHVzaChvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9LCBbXSlcbiAgKTtcblxuICBuYW1lc3BhY2UuZ3Vlc3NlcyA9IGd1ZXNzZXM7XG5cbiAgLy8gcmVwbGFjZXMgY2hhcmFjdGVycyBpbiBhIHN0cmluZyB3aGVyZSB3aXRoIHByb3ZpZGVkIHJlcGxhY2VtZW50IGNoYXJhY3RlclxuICAvLyBhbmQgaW5kZXggd2hlcmUgaXQgc2hvdWxkIGJlIHBsYWNlZFxuICAvLyBpdCByZWNlaXZlcyB0d28gYXJndW1lbnRzLCBhIHN0cmluZyBhbmQgYW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nXG4gIC8vIGEgY2hhcmFjdGVyIHRoZSB1c2VyIGd1ZXNzZWQgYW5kIGl0J3MgaW5kZXggaW4gdGhlIGFuc3dlclxuICAvLyBhbGwgY2hhcmFjdGVycyBwcm92aWRlZCBhcmUgY29udGFpbmVkIGluIHRoZSBhbnN3ZXJcbiAgY29uc3QgcmVwbGFjZSA9ICh3b3JkLCBpbnB1dCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdFN0ciA9IGlucHV0LnJlZHVjZSgocHJldmlvdXMsIGd1ZXNzKSA9PiB7XG4gICAgICAvLyBpbnNlcnQgZWFjaCBsZXR0ZXIgYWNjb3JkaW5nIHRvIGl0J3MgcHJvdmlkZWQgaW5kZXhcbiAgICAgIGlmIChndWVzcy5pbmRleCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBwcmV2aW91cy5zdWJzdHJpbmcoMCwgZ3Vlc3MuaW5kZXgpICtcbiAgICAgICAgICBndWVzcy5rZXkgK1xuICAgICAgICAgIHByZXZpb3VzLnN1YnN0cmluZyhndWVzcy5pbmRleCArIDEsIHByZXZpb3VzLmxlbmd0aClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LCB3b3JkKTtcblxuICAgIC8vIHJldHVybiBhbHRlcmVkIHN0cmluZyBhcyBvdXRwdXRcbiAgICByZXR1cm4gcmVzdWx0U3RyO1xuICB9O1xuXG4gIG5hbWVzcGFjZS5yZXBsYWNlID0gcmVwbGFjZTtcblxuICAvLyB0YWtlcyBpbiBhIG51bWJlciBpbmNyZW1lbnRzIGl0IGJ5IG9uZSBhbmQgcmV0dXJucyB0aGUgaW5jcmVtZW50ZWQgbnVtYmVyXG4gIGNvbnN0IGluYyA9IChudW0gPSAtMSkgPT4gbnVtICsgMTtcblxuICBuYW1lc3BhY2UuaW5jID0gaW5jO1xufSkoSEFOR01BTik7XG5cbmNvbnN0IGdhbWVXb3JkcyA9IEhBTkdNQU4ud29yZEZhY3RvcnkoW1xuICBbJ2JveGVyJywgJ0l0IGNvdWxkIGJlIGEgbWFuIG9yIGEgZG9nLiddLFxuICBbJ2NvbXBsaW1lbnQnLCAnU2F5IHNvbWV0aGluZyB0byBtYWtlIG1lIHNtaWxlLiddLFxuICBbJ2Jhc2tldGJhbGwnLCAnTm90aGluZyBidXQgbmV0LiddLFxuICBbJ2hpYmVybmF0ZScsICdJIGNhbiBiYXJlIHRoZSBjb2xkLiddLFxuXSwpO1xuY29uc3Qge1xuICBtYWtlRWxlbSwgbWFrZURhc2hlcywgZ3Vlc3NlcywgcmVwbGFjZSwgaW5jLFxufSA9IEhBTkdNQU47XG5jb25zdCBtZXRob2RzQXJyID0gW21ha2VFbGVtLCBtYWtlRGFzaGVzLCBndWVzc2VzLCByZXBsYWNlLCBpbmNdO1xuXG5jb25zdCBnYW1lQ29uZmlnID0gKHdvcmRzLCBtZXRob2RzKSA9PiB7XG4gIGNvbnN0IFttYWtlRWxlbSwgbWFrZURhc2hlcywgZ3Vlc3NlcywgcmVwbGFjZSwgaW5jXSA9IG1ldGhvZHM7XG5cbiAgLy8gY3JlYXRlIGFuZCBwbGFjZSBlbGVtZW50cyBpbnRvIERPTSB3aGVuIGdhbWUgaW5pbnRhbGx5IHN0YXJ0c1xuICBjb25zdCBnYW1lID0gbWFrZUVsZW0oKVxuICAgIC5hZGRDbGFzcygnZ2FtZScpXG4gICAgLmFwcGVuZFRvKGdsb2JhbC5kb2N1bWVudC5ib2R5KTtcblxuICBjb25zdCBkaXNwbGF5SGVhZFNjb3JlID0gbWFrZUVsZW0oKVxuICAgIC5hZGRDbGFzcygnZGlzcGxheV9faGVhZGluZycpXG4gICAgLmFkZENsYXNzKCdkaXNwbGF5X19oZWFkaW5nLS1zY29yZScpXG4gICAgLmFwcGVuZFRvKGdhbWUpO1xuXG4gIGNvbnN0IGRpc3BsYXlDb250ZW50V29yZCA9IG1ha2VFbGVtKClcbiAgICAuYWRkQ2xhc3MoJ2Rpc3BsYXlfX2NvbnRlbnQnKVxuICAgIC5hZGRDbGFzcygnZGlzcGxheV9fY29udGVudC0td29yZCcpXG4gICAgLmFwcGVuZFRvKGdhbWUpO1xuXG4gIGNvbnN0IHdyb25nR3Vlc3Nlc0RpdiA9IG1ha2VFbGVtKClcbiAgICAuYWRkQ2xhc3MoJ3dyb25nLWd1ZXNzZXMnKVxuICAgIC5hcHBlbmRUbyhnYW1lKTtcblxuICBjb25zdCBkaXNwbGF5SGVhZEhpbnQgPSBtYWtlRWxlbSgpO1xuXG4gIGRpc3BsYXlIZWFkSGludFxuICAgIC5hZGRDbGFzcygnZ2FtZV9faGludC1oZWFkJylcbiAgICAuYWRkQ2xhc3MoJ2Rpc3BsYXlfX2hlYWRpbmcnKVxuICAgIC5hZGRDbGFzcygnZGlzcGxheV9faGVhZGluZy0taGludCcpXG4gICAgLmFwcGVuZFRvKGdhbWUpXG4gICAgLnRleHQoJ0hpbnQnKTtcblxuICBjb25zdCBkaXNwbGF5Q29udGVudEhpbnQgPSBtYWtlRWxlbSgpXG4gICAgLmFkZENsYXNzKCdkaXNwbGF5X19jb250ZW50JylcbiAgICAuYWRkQ2xhc3MoJ2Rpc3BsYXlfX2NvbnRlbnQtLWhpbnQnKVxuICAgIC5odG1sKGA8cCBjbGFzcz1cImdhbWUtdGV4dCBoaW50LXRleHRcIj4ke3dvcmRzWzBdLmhpbnR9PC9wPmApXG4gICAgLmFwcGVuZFRvKGdhbWUpO1xuXG4gIGNvbnN0IHsgYm9keSB9ID0gZ2xvYmFsLmRvY3VtZW50O1xuXG4gIC8vIHNldCBpbml0aWFsIHZhbHVlcyBmb3IgZ2FtZVxuXG4gIGxldCBpbnB1dCA9IFtdO1xuXG4gIC8vIHRoaXMgc2V0cyB0aGUgY291bnQgdG8gemVyb1xuICAvLyB0aGUgaW5jIGZ1bmN0aW9uIHJldHVybnMgemVybyB3aGVuIGl0IGlzIHBhc3NlZCBubyBhcmd1bWVudHNcbiAgLy8gb3RoZXJ3aXNlIGl0IHRha2VzIGEgbnVtYmVyIGFzIGFuIGFyZ3VtZW50IGFuZCB0dXJucyB0aGF0IG51bWJlciBpbmNyZW1lbnRlZCBieSAxXG4gIC8vIGluYyg1KSBpcyA1ICsgMSwgd2hpY2ggcmV0dXJucyA2LlxuXG4gIGxldCBjb3VudCA9IGluYygpO1xuXG4gIGxldCB7IHdvcmQgfSA9IHdvcmRzW2NvdW50XTtcblxuICBsZXQgd2lucyA9IDA7XG5cbiAgbGV0IGNoYW5jZXMgPSA1O1xuXG4gIGxldCBndWVzc2VkTGV0dGVycyA9IFtdO1xuXG4gIGxldCBwdXp6bGVXb3JkID0gbWFrZURhc2hlcyh3b3JkKTtcblxuICAvLyAjIyMjIyMjIyMjIyMgU0VUVElORyBJTklUSUFMIERPTSBFTEVNRU5UUyAjIyMjIyMjIyMjIyMjIyNcbiAgY29uc3Qgd2luc0RpdiA9IG1ha2VFbGVtKClcbiAgICAuYWRkQ2xhc3MoJ2dhbWVfX3Njb3JlLS13aW5zJylcbiAgICAuaHRtbChgd2luczogPHNwYW4gY2xhc3M9XCJnYW1lX19zY29yZS0tdGFsbHlcIj4ke3dpbnN9PC9zcGFuPmApXG4gICAgLmFwcGVuZFRvKGRpc3BsYXlIZWFkU2NvcmUpO1xuICBjb25zdCBjaGFuY2VzRGl2ID0gbWFrZUVsZW0oKVxuICAgIC5hZGRDbGFzcygnZ2FtZV9fc2NvcmUtLWNoYW5jZXMnKVxuICAgIC5odG1sKGBjaGFuY2VzOiA8c3BhbiBjbGFzcz1cImdhbWVfX3Njb3JlLS10YWxseVwiPiR7Y2hhbmNlc308L3NwYW4+YClcbiAgICAuYXBwZW5kVG8oZGlzcGxheUhlYWRTY29yZSk7XG5cbiAgY29uc3Qgd29yZFByb2dyZXNzRGl2ID0gbWFrZUVsZW0oKVxuICAgIC5hZGRDbGFzcygnZ2FtZS10ZXh0JylcbiAgICAuYWRkQ2xhc3MoJ2Rpc3BsYXlfX2NvbnRlbnQtLXRleHQnKVxuICAgIC5odG1sKHB1enpsZVdvcmQpXG4gICAgLmFwcGVuZFRvKGRpc3BsYXlDb250ZW50V29yZCk7XG5cbiAgY29uc3QgbW9kYWxCYWNrZHJvcCA9IG1ha2VFbGVtKClcbiAgICAuYWRkQ2xhc3MoJ21vZGFsX19iYWNrZHJvcCcpXG4gICAgLmhpZGUoKVxuICAgIC5hcHBlbmRUbyhib2R5KTtcbiAgY29uc3QgbW9kYWwgPSBtYWtlRWxlbSgpXG4gICAgLmFkZENsYXNzKCdtb2RhbCcpXG4gICAgLmFwcGVuZFRvKG1vZGFsQmFja2Ryb3ApO1xuXG4gIGNvbnN0IG1vZGFsTWVzc2FnZSA9IG1ha2VFbGVtKClcbiAgICAuYWRkQ2xhc3MoJ21vZGFsLS1tZXNzYWdlJylcbiAgICAuYXBwZW5kVG8obW9kYWwpO1xuXG4gIGxldCBjYW5JbmNTY29yZXMgPSB0cnVlO1xuICBsZXQgYWNrbm93bGVkZ2VHdWVzc2VzID0gdHJ1ZTtcblxuICBjb25zdCBzb2Z0UmVzZXQgPSAoKSA9PiB7XG4gICAgZ3Vlc3NlZExldHRlcnMgPSBbXTtcbiAgICBjb3VudCA9IGluYyhjb3VudCk7XG4gICAgd29yZCA9IHdvcmRzW2NvdW50XS53b3JkO1xuICAgIHB1enpsZVdvcmQgPSBtYWtlRGFzaGVzKHdvcmQpO1xuICAgIGlucHV0ID0gW107XG4gICAgY2hhbmNlcyA9IDU7XG4gICAgd29yZFByb2dyZXNzRGl2LnRleHQoYFdvcmQgc28gZmFyOiAke3B1enpsZVdvcmR9YCk7XG4gICAgLy8gcHJpbnQgaGludCB0byBzY3JlZW5cbiAgICBkaXNwbGF5Q29udGVudEhpbnQuaHRtbChgPHAgY2xhc3M9XCJnYW1lLXRleHQgaGludC10ZXh0XCI+JHt3b3Jkc1tjb3VudF0uaGludH08L3A+YClcbiAgICAgIC5hZGRDbGFzcygnZGlzcGxheV9fY29udGVudCcpO1xuXG4gICAgd3JvbmdHdWVzc2VzRGl2LmVtcHR5KCk7XG4gIH07XG5cbiAgLy8gUkVTVEFSVFMgR0FNRSAtLSBTVEFSVFMgRlJPTSBUSEUgQkVHSU5OSU5HXG4gIGNvbnN0IGhhcmRSZXNldCA9ICgpID0+IHtcbiAgICBndWVzc2VkTGV0dGVycyA9IFtdO1xuICAgIGNhbkluY1Njb3JlcyA9IHRydWU7XG4gICAgY291bnQgPSBpbmMoKTtcbiAgICB3b3JkID0gd29yZHNbY291bnRdLndvcmQ7XG4gICAgcHV6emxlV29yZCA9IG1ha2VEYXNoZXMod29yZCk7XG4gICAgaW5wdXQgPSBbXTtcbiAgICBjaGFuY2VzID0gNTtcbiAgICB3aW5zID0gMDtcbiAgICB3b3JkUHJvZ3Jlc3NEaXYuaHRtbChwdXp6bGVXb3JkKTtcbiAgICAvLyBwcmludCBoaW50IHRvIHNjcmVlblxuICAgIGRpc3BsYXlDb250ZW50SGludC5odG1sKGA8cCBjbGFzcz1cImdhbWUtdGV4dCBoaW50LXRleHRcIj4ke3dvcmRzW2NvdW50XS5oaW50fTwvcD5gKTtcbiAgICB3cm9uZ0d1ZXNzZXNEaXYuZW1wdHkoKTtcbiAgfTtcblxuICAvLyBDT01NRU5DRSBHQU1FIFdIRU4gVVNFUiBQUkVTU0VTIFRIRSBFTlRFUiBLRVlcbiAgYm9keS5vbmtleXVwID0gKGUpID0+IHtcbiAgICBjb25zdCBpc0FscGhhYmV0ID0gc3RyID0+IC9eW2EtekEtWigpXSQvLnRlc3Qoc3RyKTtcblxuICAgIC8vIGNhcHR1cmUga2V5IHN0cm9rZVxuICAgIGxldCB7IGtleSwgY3RybEtleSB9ID0gZTtcblxuXG4gICAgLy8gaWYga2V5IGlzIGEgbGV0dGVyIHR1cm4gaXQgdG8gbG93ZXIgY2FzZSBhbmQgcmVhc3NpZ24gaXQgdG8gYmFjayB0byBrZXlcbiAgICBpZiAoaXNBbHBoYWJldChrZXkpKSBrZXkgPSBrZXkudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIG9ubHkgcHJlY2VkZSBpZiBDVFJMIGlzbid0IHByZXNzZWQgYWxvbmcgd2l0aCBhbHBoYWJldCBrZXlcbiAgICBpZiAoY3RybEtleSkgcmV0dXJuO1xuXG4gICAgLy9cbiAgICBjb25zdCB1c2VyR3Vlc3MgPSBndWVzc2VzKHdvcmQsIGtleSk7XG5cbiAgICAvLyB0aGlzIGZ1bmN0aW9uIHRlc3RzIHRoZSBrZXkgZW50ZXJlZCB0byBmaW5kIG91dCBpZiBpdCBpcyBhbiBhbHBoYWJldGljYWwgY2hhcmFjdGVyXG4gICAgY29uc3QgYWxwaGFiZXRUZXN0UGFzdCA9IGlzQWxwaGFiZXQoa2V5KTtcblxuICAgIC8vIHNwcmVhZCBhcnJheSBhbmQgcHVzaCB0aGVtIGludG8gdGhlIGlucHV0IGFycmF5XG4gICAgaWYgKGFja25vd2xlZGdlR3Vlc3NlcykgaW5wdXQucHVzaCguLi51c2VyR3Vlc3MpO1xuXG4gICAgcHV6emxlV29yZCA9IHJlcGxhY2UocHV6emxlV29yZCwgaW5wdXQpO1xuXG5cbiAgICAvLyAjIyMjIyMjIyMjIyMjIyBVU0VSIEdVRVNTRUQgV1JPTkcgIyMjIyMjIyMjIyMjI1xuICAgIGlmIChcbiAgICAgICF3b3Jkc1tjb3VudF0uaXNJbmNsdWRlZChrZXkpICYmXG4gICAgICBjYW5JbmNTY29yZXMgPT09IHRydWUgJiZcbiAgICAgIGNoYW5jZXMgPj0gMSAmJlxuICAgICAgYWxwaGFiZXRUZXN0UGFzdCAmJlxuICAgICAgIWd1ZXNzZWRMZXR0ZXJzLmluY2x1ZGVzKGtleSlcbiAgICApIHtcbiAgICAgIGNoYW5jZXMtLTtcbiAgICAgIGd1ZXNzZWRMZXR0ZXJzLnB1c2goa2V5KTtcbiAgICAgIG1ha2VFbGVtKClcbiAgICAgICAgLmFkZENsYXNzKCd3cm9uZy1sZXR0ZXInKVxuICAgICAgICAudGV4dChrZXkpXG4gICAgICAgIC5hcHBlbmRUbyh3cm9uZ0d1ZXNzZXNEaXYpO1xuXG4gICAgICB3cm9uZ0d1ZXNzZXNEaXZcbiAgICAgICAgLmFkZENsYXNzKCd3aWdnbGUtYW5pbWF0aW9uJyk7XG5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB3cm9uZ0d1ZXNzZXNEaXZcbiAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ3dpZ2dsZS1hbmltYXRpb24nKTtcbiAgICAgIH0sIDEwMDApO1xuICAgIH1cblxuICAgIC8vICMjIyMjIyMjIyMgVVNFUiBFWEhBVVNUUyBBTEwgSElTIEdVRVNTRVMgIyMjIyMjIyMjIyMjIyNcbiAgICBpZiAoIWNoYW5jZXMpIHtcbiAgICAgIGFja25vd2xlZGdlR3Vlc3NlcyA9IGZhbHNlO1xuICAgICAgLy8gYWxlcnQoJ1lvdSBsb3N0IScpO1xuICAgICAgLy8gY291bnQgPSBpbmMoKTtcbiAgICAgIG1vZGFsTWVzc2FnZS5odG1sKGA8c3BhbiBjbGFzcz1cIm1vZGFsX19oZWFkaW5nLS1sb3NzXCI+WW91IGxvc2UhPC9zcGFuPiBcbiAgICAgICAgICAgIDxicj4gXG4gICAgICAgICAgICBUaGUgd29yZCB3YXMgPHNwYW4gY2xhc3M9XCJtb2RhbF9fbm90YWJsZS0tbG9zc1wiPlwiJHt3b3Jkc1tjb3VudF0ud29yZH1cIjwvc3Bhbj5cbiAgICAgICAgICAgIDxicj5cbiAgICAgICAgICAgIFByZXNzIDxzcGFuIGNsYXNzPVwibW9kYWxfX25vdGFibGUtLWxvc3NcIj5cIkVudGVyXCI8L3NwYW4+IHRvIHN0YXJ0IG92ZXIuYCk7XG4gICAgICBtb2RhbEJhY2tkcm9wLnNob3coKTtcbiAgICAgIGlmIChrZXkgPT09ICdFbnRlcicpIHtcbiAgICAgICAgY291bnQgPSBpbmMoKTtcbiAgICAgICAgd2lucyA9IGluYygpO1xuICAgICAgICBtb2RhbEJhY2tkcm9wLmhpZGUoKTtcbiAgICAgICAgd3JvbmdHdWVzc2VzRGl2LmVtcHR5KCk7XG4gICAgICAgIGFja25vd2xlZGdlR3Vlc3NlcyA9IHRydWU7XG4gICAgICAgIHdvcmQgPSB3b3Jkc1tjb3VudF0ud29yZDtcbiAgICAgICAgcHV6emxlV29yZCA9IG1ha2VEYXNoZXMod29yZCk7XG4gICAgICAgIGlucHV0ID0gW107XG4gICAgICAgIGNoYW5jZXMgPSA1O1xuICAgICAgICB3b3JkUHJvZ3Jlc3NEaXYuaHRtbChwdXp6bGVXb3JkKTtcbiAgICAgICAgLy8gcHJpbnQgaGludCB0byBzY3JlZW5cbiAgICAgICAgZGlzcGxheUNvbnRlbnRIaW50Lmh0bWwoYDxwIGNsYXNzPVwiZ2FtZS10ZXh0IGhpbnQtdGV4dFwiPiR7d29yZHNbY291bnRdLmhpbnR9PC9wPmApO1xuICAgICAgICB3aW5zRGl2Lmh0bWwoYHdpbnM6IDxzcGFuIGNsYXNzPVwiZ2FtZV9fc2NvcmUtLXRhbGx5XCI+JHt3aW5zfTwvc3Bhbj5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwcmludCBoaW50IHRvIHNjcmVlblxuICAgIGRpc3BsYXlDb250ZW50SGludC5odG1sKGA8cCBjbGFzcz1cImdhbWUtdGV4dCBoaW50LXRleHRcIj4ke3dvcmRzW2NvdW50XS5oaW50fTwvcD5gKTtcblxuICAgIC8vICMjIyMjIyMjIyMjIyMjIyMgVVNFUiBHT1QgQUxMIFRIRSBMRVRURVJTICMjIyMjIyMjIyMjIyMjI1xuICAgIGlmICh3b3Jkc1tjb3VudF0uaXNNYXRjaGVkKHB1enpsZVdvcmQpKSB7XG4gICAgICBpZiAoY2FuSW5jU2NvcmVzKSB3aW5zKys7XG4gICAgICBjYW5JbmNTY29yZXMgPSBmYWxzZTtcbiAgICAgIHdpbnNEaXYuaHRtbChgd2luczogPHNwYW4gY2xhc3M9XCJnYW1lX19zY29yZS0tdGFsbHlcIj4ke3dpbnN9PC9zcGFuPmApO1xuICAgICAgd29yZFByb2dyZXNzRGl2LnRleHQoYFdvcmQgc28gZmFyOiAke3B1enpsZVdvcmR9YCk7XG4gICAgICAvLyBwcmludCBoaW50IHRvIHNjcmVlblxuICAgICAgZGlzcGxheUNvbnRlbnRIaW50Lmh0bWwoYDxwIGNsYXNzPVwiZ2FtZS10ZXh0IGhpbnQtdGV4dFwiPiR7d29yZHNbY291bnRdLmhpbnR9PC9wPmApO1xuICAgICAgLy8gbW9kYWxXb3JkRGlzcGxheS50ZXh0KHB1enpsZVdvcmQpO1xuICAgICAgbW9kYWxNZXNzYWdlLmh0bWwoYDxoMiBjbGFzcz1cIm1vZGFsX19oZWFkaW5nLS13aW5cIj5Db25ncmF0dWxhdGlvbnMhPC9oMj4gXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJtb2RhbF9fbm90YWJsZVwiPllvdSdyZSBjb3JyZWN0LiBUaGUgd29yZCdzIDxzcGFuIGNsYXNzPVwibW9kYWxfX25vdGFibGUtLXdpblwiPlwiJHtwdXp6bGVXb3JkfVwiPC9zcGFuPlxuICAgICAgICAgICAgICAgIFByZXNzIDxzcGFuIGNsYXNzPVwibW9kYWxfX25vdGFibGUtLXdpblwiPlwiRW50ZXJcIjwvc3Bhbj4gdG8gYXR0ZW1wdCB0aGUgbmV4dCB3b3JkLjwvcD5gKTtcbiAgICAgIG1vZGFsQmFja2Ryb3Auc2hvdygpO1xuXG4gICAgICAvLyAgcGxheWVyIGNvbXBsZXRlZCBldmVyeSB3b3JkIC0tLS0tVE9ETy0tLS0tXG4gICAgICBpZiAod2lucyA9PT0gd29yZHMubGVuZ3RoKSB7XG4gICAgICAgIG1vZGFsTWVzc2FnZS5odG1sKGBcbiAgICAgICAgICAgICAgICAgICAgPGgxIGNsYXNzPVwibW9kYWxfX2hlYWRpbmctLXdpblwiPkNvbmdyYXR1bGF0aW9uczwvaDE+XG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwibW9kYWwtLW1lc3NhZ2VcIj5Zb3UndmUgZm91bmQgYWxsIHRoZSB3b3Jkcy4gUHJlc3MgRW50ZXIgdG8gb3ZlcjwvcD5cbiAgICAgICAgICAgICAgICAgYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIG1vdmUgdG8gbmV4dCB3b3JkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBlbnRlclxuICAgICAgaWYgKGtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICBjYW5JbmNTY29yZXMgPSB0cnVlO1xuICAgICAgICAvLyAjIyMjIyMgVVNFUiBHT1QgQUxMIFRIRSBXT1JEUyAjIyMjIyMjI1xuICAgICAgICBpZiAod29yZHNbY291bnRdICE9PSB3b3Jkc1t3b3Jkcy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgIC8vICB0byBuZXh0IHdvcmQgYW5kIHJlc2V0IG5lZ2F0aXZlIHJlY29yZCByZWdhcmRpbmcgZWF0IGluZGl2aWR1YWwgd29yZFxuICAgICAgICAgIHNvZnRSZXNldCgpO1xuICAgICAgICAgIG1vZGFsQmFja2Ryb3AuaGlkZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoZSBnYW1lIHJlc2V0cyB3aGVuIGFsbCB0aGUgd29yZHMgaGF2ZSBiZWVuIHNvbHZlZFxuICAgICAgICAgIGhhcmRSZXNldCgpO1xuICAgICAgICAgIG1vZGFsQmFja2Ryb3AuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hhbmNlc0Rpdi5odG1sKGBjaGFuY2VzOiA8c3BhbiBjbGFzcz1cImdhbWVfX3Njb3JlLS10YWxseVwiPiR7Y2hhbmNlc308L3NwYW4+YCk7XG4gICAgd2luc0Rpdi5odG1sKGB3aW5zOiA8c3BhbiBjbGFzcz1cImdhbWVfX3Njb3JlLS10YWxseVwiPiR7d2luc308L3NwYW4+YCk7XG4gICAgd29yZFByb2dyZXNzRGl2Lmh0bWwocHV6emxlV29yZCk7XG4gIH07XG59O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09IEVWRU5UIEhBTkRMRVIgRk9SIFNUQVJUSU5HIEdBTUU9PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgaGFuZGxlS2V5cHJlc3MgPSAoZSkgPT4ge1xuICBjb25zdCB7IGtleSwgdGFyZ2V0IH0gPSBlO1xuXG4gIGNvbnN0IGludHJvID0gZ2xvYmFsLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbnRybycpO1xuXG4gIGlmIChrZXkgPT09ICdFbnRlcicpIHtcbiAgICBnYW1lQ29uZmlnKGdhbWVXb3JkcywgbWV0aG9kc0Fycik7XG4gICAgaW50cm8ucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChpbnRybyk7XG5cbiAgICAvLyByZW1vdmUgbGlzdGVuZXIgc28gdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgcnVuIG9uY2UuLi5cbiAgICAvLyB3aGVuIHRoZSB1c2VyIGluaXRpYWxseSBjb21lcyB0byB0aGUgc2l0ZVxuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGhhbmRsZUtleXByZXNzKTtcbiAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVLZXlwcmVzcyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGhhbmRsZUNsaWNrKGUpIHtcbiAgY29uc3QgeyB0YXJnZXQgfSA9IGU7XG5cbiAgY29uc3QgaW50cm8gPSBnbG9iYWwuZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmludHJvJyk7XG5cbiAgaW50cm8ucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChpbnRybyk7XG4gIGdhbWVDb25maWcoZ2FtZVdvcmRzLCBtZXRob2RzQXJyKTtcblxuICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGljayk7XG4gIGdsb2JhbC5kb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgaGFuZGxlS2V5cHJlc3MpO1xufVxuXG5nbG9iYWwuZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGhhbmRsZUtleXByZXNzKTtcbmNvbnN0IGludHJvVGV4dCA9IGdsb2JhbC5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW50cm8tLXRleHQnKTtcbmludHJvVGV4dC5vbmNsaWNrID0gaGFuZGxlQ2xpY2s7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2FwcC5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTtBQUNBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBS0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\n} catch(e) {\n\t// This works if the window reference is available\n\tif(typeof window === \"object\")\n\t\tg = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/MzY5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XG59IGNhdGNoKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcblx0XHRnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zdHlsZS9tYWluLnNjc3M/NDYwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3N0eWxlL21haW4uc2Nzc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n");

/***/ })
/******/ ]);