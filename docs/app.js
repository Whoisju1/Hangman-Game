/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__style_main_scss__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__style_main_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__style_main_scss__);\n// import styles\n\n\nconst HANGMAN = {};\n\n// -------------------------NAMESPACE -------------------------\n(namespace => {\n  // -----------------------WORD CLASS------------------------\n  // used to make words for game\n  class Word {\n    constructor(word, hint) {\n      this.word = word.toLowerCase();\n      this.hint = hint;\n      this.isMatched = this.isMatched.bind(this);\n      this.isIncluded = this.isIncluded.bind(this);\n    }\n\n    // method to test if user letter choice is present in word\n    isIncluded(char) {\n      return this.word.includes(char.toLowerCase().trim());\n    }\n\n    // method to test if word is correct\n    isMatched(letters) {\n      return this.word === letters.toLowerCase().trim();\n    }\n  }\n\n  // ----------------------WORD FACTORY------------------------\n  // make single word or an array of words and make it a property of HANGMAN\n  // it takes an a single string, multiple stings, or an array of stings as an argument\n  namespace.wordFactory = (...word) => {\n    // if argument is an array make it an array by destructuring it\n    if (Array.isArray(...word)) [word] = word;\n    // iterate through an array of strings and return an array of objects\n    if (word.length > 1) return word.map(item => new Word(...item));\n\n    // if argument is a single string destructure the array and output a string\n    const [singleWord] = word;\n    // make a single object\n    return new Word(singleWord);\n  };\n\n  // ------------------ARRAY ITERATOR ----------------------------------\n\n  // loop through array of words and execute callback function using recursive function\n  const arrayIterator = (wordList, cb) => {\n    const [a, ...b] = wordList;\n    cb(a);\n    if (wordList.length === 1) return;\n    arrayIterator(b, cb);\n  };\n\n  namespace.arrayIterator = arrayIterator;\n\n  // This method takes in a string and outputs a string of underscores\n  // proportionate to the number of characters contained in the string\n  const makeDashes = answer => {\n    const dashed = [];\n    (function looper(answer) {\n      const [a, ...b] = [...answer];\n\n      dashed.push('_');\n      if (answer.length === 1) return;\n      looper(b);\n    })(answer);\n    return dashed.join('');\n  };\n\n  namespace.makeDashes = makeDashes;\n\n  // this is a method used for DOM manipulation\n  // the names of the functions within it borrow from jQuery\n  const makeElem = (elemName = 'div') => {\n    const elem = global.document.createElement(elemName);\n\n    // insert element into another element\n    elem.appendTo = parent => {\n      parent.appendChild(elem);\n      return elem;\n    };\n\n    // add text to element\n    elem.text = text => {\n      elem.textContent = text;\n      return elem;\n    };\n\n    // add HTML to element\n    elem.html = html => {\n      elem.innerHTML = html;\n      return elem;\n    };\n\n    // empty the element of all it's content\n    elem.empty = () => {\n      elem.innerHTML = '';\n      return elem;\n    };\n\n    // hide the element\n    elem.hide = () => {\n      elem.style.visibility = 'hidden';\n      return elem;\n    };\n\n    // show element\n    elem.show = () => {\n      elem.style.visibility = 'visible';\n      return elem;\n    };\n\n    // add CSS class to element\n    elem.addClass = className => {\n      elem.classList.add(className);\n      return elem;\n    };\n\n    // remove CSS class from element\n    elem.removeClass = className => {\n      elem.classList.remove(className);\n      return elem;\n    };\n\n    return elem;\n  };\n\n  namespace.makeElem = makeElem;\n\n  // this takes in two arguments, the answer and the user's guess\n  // if the letter guess is present in the answer it outputs an array of objects with the\n  // letter as a string and the index at which the letter is present in the answer string\n  const guesses = (answer, letterGuessed) =>\n  // spread the characters in the string and place them in an array\n  // then iterate through them using the reduce function which returns a array that contains\n  // all the letter guessed and the the index at which it is matched in the answers string\n  [...answer].reduce((arr, letter, index) => {\n    if (letterGuessed === letter) {\n      const obj = {\n        key: letterGuessed,\n        index\n      };\n      arr.push(obj);\n    }\n    return arr;\n  }, []);\n\n  namespace.guesses = guesses;\n\n  // replaces characters in a string where with provided replacement character \n  // and index where it should be placed\n  // it receives two arguments, a string and an array of objects containing \n  // a character the user guessed and it's index in the answer\n  // all characters provided are contained in the answer\n  const replace = (word, input) => {\n    const resultStr = input.reduce((previous, guess) => {\n      // insert each letter according to it's provided index\n      if (guess.index !== -1) {\n        return previous.substring(0, guess.index) + guess.key + previous.substring(guess.index + 1, previous.length);\n      }\n    }, word);\n\n    // return altered string as output\n    return resultStr;\n  };\n\n  namespace.replace = replace;\n\n  // takes in a number increments it by one and returns the incremented number\n  const inc = (num = -1) => num + 1;\n\n  namespace.inc = inc;\n})(HANGMAN);\n\nconst gameWords = HANGMAN.wordFactory([['boxer', 'It could be a man or a dog.'], ['compliment', 'Say something to make me smile.'], ['basketball', 'Nothing but net.'], ['hibernate', 'I can bare the cold.']]);\nconst {\n  makeElem, makeDashes, guesses, replace, inc\n} = HANGMAN;\nconst methodsArr = [makeElem, makeDashes, guesses, replace, inc];\n\nconst gameConfig = (words, methods) => {\n  const [makeElem, makeDashes, guesses, replace, inc] = methods;\n\n  // create and place elements into DOM when game inintally starts\n  const game = makeElem().addClass('game').appendTo(global.document.body);\n\n  const displayHeadScore = makeElem().addClass('display__heading').addClass('display__heading--score').appendTo(game);\n\n  const displayContentWord = makeElem().addClass('display__content').addClass('display__content--word').appendTo(game);\n\n  const wrongGuessesDiv = makeElem().addClass('wrong-guesses').appendTo(game);\n\n  const displayHeadHint = makeElem();\n\n  displayHeadHint.addClass('game__hint-head').addClass('display__heading').addClass('display__heading--hint').appendTo(game).text('Hint');\n\n  const displayContentHint = makeElem().addClass('display__content').addClass('display__content--hint').html(`<p class=\"game-text hint-text\">${words[0].hint}</p>`).appendTo(game);\n\n  const { body } = global.document;\n\n  // set initial values for game\n\n  let input = [];\n\n  // this sets the count to zero\n  // the inc function returns zero when it is passed no arguments\n  // otherwise it takes a number as an argument and turns that number incremented by 1\n  // inc(5) is 5 + 1, which returns 6.\n\n  let count = inc();\n\n  let { word } = words[count];\n\n  let wins = 0;\n\n  let chances = 5;\n\n  let guessedLetters = [];\n\n  let puzzleWord = makeDashes(word);\n\n  // ############ SETTING INITIAL DOM ELEMENTS ###############\n  const winsDiv = makeElem().addClass('game__score--wins').html(`wins: <span class=\"game__score--tally\">${wins}</span>`).appendTo(displayHeadScore);\n  const chancesDiv = makeElem().addClass('game__score--chances').html(`chances: <span class=\"game__score--tally\">${chances}</span>`).appendTo(displayHeadScore);\n\n  const wordProgressDiv = makeElem().addClass('game-text').addClass('display__content--text').html(puzzleWord).appendTo(displayContentWord);\n\n  const modalBackdrop = makeElem().addClass('modal__backdrop').hide().appendTo(body);\n  const modal = makeElem().addClass('modal').appendTo(modalBackdrop);\n\n  const modalMessage = makeElem().addClass('modal--message').appendTo(modal);\n\n  let canIncScores = true;\n  let acknowledgeGuesses = true;\n\n  const softReset = () => {\n    guessedLetters = [];\n    count = inc(count);\n    word = words[count].word;\n    puzzleWord = makeDashes(word);\n    input = [];\n    chances = 5;\n    wordProgressDiv.text(`Word so far: ${puzzleWord}`);\n    // print hint to screen\n    displayContentHint.html(`<p class=\"game-text hint-text\">${words[count].hint}</p>`).addClass('display__content');\n\n    wrongGuessesDiv.empty();\n  };\n\n  // RESTARTS GAME -- STARTS FROM THE BEGINNING\n  const hardReset = () => {\n    guessedLetters = [];\n    canIncScores = true;\n    count = inc();\n    word = words[count].word;\n    puzzleWord = makeDashes(word);\n    input = [];\n    chances = 5;\n    wins = 0;\n    wordProgressDiv.html(puzzleWord);\n    // print hint to screen\n    displayContentHint.html(`<p class=\"game-text hint-text\">${words[count].hint}</p>`);\n    wrongGuessesDiv.empty();\n  };\n\n  // COMMENCE GAME WHEN USER PRESSES THE ENTER KEY\n  body.onkeyup = e => {\n    const isAlphabet = str => /^[a-zA-Z()]$/.test(str);\n\n    // capture key stroke\n    let { key, ctrlKey } = e;\n\n    // if key is a letter turn it to lower case and reassign it to back to key\n    if (isAlphabet(key)) key = key.toLowerCase();\n\n    // only precede if CTRL isn't pressed along with alphabet key\n    if (ctrlKey) return;\n\n    //\n    const userGuess = guesses(word, key);\n\n    // this function tests the key entered to find out if it is an alphabetical character\n    const alphabetTestPast = isAlphabet(key);\n\n    // spread array and push them into the input array\n    if (acknowledgeGuesses) input.push(...userGuess);\n\n    puzzleWord = replace(puzzleWord, input);\n\n    // ############## USER GUESSED WRONG #############\n    if (!words[count].isIncluded(key) && canIncScores === true && chances >= 1 && alphabetTestPast && !guessedLetters.includes(key)) {\n      chances--;\n      guessedLetters.push(key);\n      makeElem().addClass('wrong-letter').text(key).appendTo(wrongGuessesDiv);\n\n      wrongGuessesDiv.addClass('wiggle-animation');\n\n      setTimeout(() => {\n        wrongGuessesDiv.removeClass('wiggle-animation');\n      }, 1000);\n    }\n\n    // ########## USER EXHAUSTS ALL HIS GUESSES ##############\n    if (!chances) {\n      acknowledgeGuesses = false;\n      // alert('You lost!');\n      // count = inc();\n      modalMessage.html(`<span class=\"modal__heading--loss\">You lose!</span> \n            <br> \n            The word was <span class=\"modal__notable--loss\">\"${words[count].word}\"</span>\n            <br>\n            Press <span class=\"modal__notable--loss\">\"Enter\"</span> to start over.`);\n      modalBackdrop.show();\n      if (key === 'Enter') {\n        count = inc();\n        wins = inc();\n        modalBackdrop.hide();\n        wrongGuessesDiv.empty();\n        acknowledgeGuesses = true;\n        word = words[count].word;\n        puzzleWord = makeDashes(word);\n        input = [];\n        chances = 5;\n        wordProgressDiv.html(puzzleWord);\n        // print hint to screen\n        displayContentHint.html(`<p class=\"game-text hint-text\">${words[count].hint}</p>`);\n        winsDiv.html(`wins: <span class=\"game__score--tally\">${wins}</span>`);\n      }\n    }\n\n    // print hint to screen\n    displayContentHint.html(`<p class=\"game-text hint-text\">${words[count].hint}</p>`);\n\n    // ################ USER GOT ALL THE LETTERS ###############\n    if (words[count].isMatched(puzzleWord)) {\n      if (canIncScores) wins++;\n      canIncScores = false;\n      winsDiv.html(`wins: <span class=\"game__score--tally\">${wins}</span>`);\n      wordProgressDiv.text(`Word so far: ${puzzleWord}`);\n      // print hint to screen\n      displayContentHint.html(`<p class=\"game-text hint-text\">${words[count].hint}</p>`);\n      // modalWordDisplay.text(puzzleWord);\n      modalMessage.html(`<h2 class=\"modal__heading--win\">Congratulations!</h2> \n                \n                <p class=\"modal__notable\">You're correct. The word's <span class=\"modal__notable--win\">\"${puzzleWord}\"</span>\n                Press <span class=\"modal__notable--win\">\"Enter\"</span> to attempt the next word.</p>`);\n      modalBackdrop.show();\n\n      //  player completed every word -----TODO-----\n      if (wins === words.length) {\n        modalMessage.html(`\n                    <h1 class=\"modal__heading--win\">Congratulations</h1>\n                    <p class=\"modal--message\">You've found all the words. Press Enter to over</p>\n                 `);\n      }\n\n      // move to next word when the user presses enter\n      if (key === 'Enter') {\n        canIncScores = true;\n        // ###### USER GOT ALL THE WORDS ########\n        if (words[count] !== words[words.length - 1]) {\n          //  to next word and reset negative record regarding eat individual word\n          softReset();\n          modalBackdrop.hide();\n        } else {\n          // the game resets when all the words have been solved\n          hardReset();\n          modalBackdrop.hide();\n        }\n      }\n    }\n\n    chancesDiv.html(`chances: <span class=\"game__score--tally\">${chances}</span>`);\n    winsDiv.html(`wins: <span class=\"game__score--tally\">${wins}</span>`);\n    wordProgressDiv.html(puzzleWord);\n  };\n};\n\n// =================== EVENT HANDLER FOR STARTING GAME=======================\nconst handleKeypress = e => {\n  const { key, target } = e;\n\n  const intro = global.document.querySelector('.intro');\n\n  if (key === 'Enter') {\n    gameConfig(gameWords, methodsArr);\n    intro.classList.add('intro--remove');\n\n    // remove listener so that this function is only run once, \n    // when the user initially comes to the site\n    target.removeEventListener('keypress', handleKeypress);\n    target.removeEventListener('click', handleKeypress);\n  }\n};\n\nfunction handleClick(e) {\n  const { target } = e;\n\n  const intro = global.document.querySelector('.intro');\n\n  intro.classList.add('intro--remove');\n  gameConfig(gameWords, methodsArr);\n\n  target.removeEventListener('click', handleClick);\n  global.document.body.removeEventListener('keypress', handleKeypress);\n}\n\nglobal.document.body.addEventListener('keypress', handleKeypress);\nconst introText = global.document.querySelector('.intro--text');\nintroText.onclick = handleClick;\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(1)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvYXBwLmpzP2JkOWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaW1wb3J0IHN0eWxlc1xuaW1wb3J0ICcuL3N0eWxlL21haW4uc2Nzcyc7XG5cbmNvbnN0IEhBTkdNQU4gPSB7fTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLU5BTUVTUEFDRSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4oKG5hbWVzcGFjZSkgPT4ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVdPUkQgQ0xBU1MtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gdXNlZCB0byBtYWtlIHdvcmRzIGZvciBnYW1lXG4gIGNsYXNzIFdvcmQge1xuICAgIGNvbnN0cnVjdG9yKHdvcmQsIGhpbnQpIHtcbiAgICAgIHRoaXMud29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRoaXMuaGludCA9IGhpbnQ7XG4gICAgICB0aGlzLmlzTWF0Y2hlZCA9IHRoaXMuaXNNYXRjaGVkLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmlzSW5jbHVkZWQgPSB0aGlzLmlzSW5jbHVkZWQuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBtZXRob2QgdG8gdGVzdCBpZiB1c2VyIGxldHRlciBjaG9pY2UgaXMgcHJlc2VudCBpbiB3b3JkXG4gICAgaXNJbmNsdWRlZChjaGFyKSB7XG4gICAgICByZXR1cm4gdGhpcy53b3JkLmluY2x1ZGVzKGNoYXIudG9Mb3dlckNhc2UoKS50cmltKCkpO1xuICAgIH1cblxuICAgIC8vIG1ldGhvZCB0byB0ZXN0IGlmIHdvcmQgaXMgY29ycmVjdFxuICAgIGlzTWF0Y2hlZChsZXR0ZXJzKSB7XG4gICAgICByZXR1cm4gdGhpcy53b3JkID09PSBsZXR0ZXJzLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1XT1JEIEZBQ1RPUlktLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gbWFrZSBzaW5nbGUgd29yZCBvciBhbiBhcnJheSBvZiB3b3JkcyBhbmQgbWFrZSBpdCBhIHByb3BlcnR5IG9mIEhBTkdNQU5cbiAgLy8gaXQgdGFrZXMgYW4gYSBzaW5nbGUgc3RyaW5nLCBtdWx0aXBsZSBzdGluZ3MsIG9yIGFuIGFycmF5IG9mIHN0aW5ncyBhcyBhbiBhcmd1bWVudFxuICBuYW1lc3BhY2Uud29yZEZhY3RvcnkgPSAoLi4ud29yZCkgPT4ge1xuICAgIC8vIGlmIGFyZ3VtZW50IGlzIGFuIGFycmF5IG1ha2UgaXQgYW4gYXJyYXkgYnkgZGVzdHJ1Y3R1cmluZyBpdFxuICAgIGlmIChBcnJheS5pc0FycmF5KC4uLndvcmQpKSBbd29yZF0gPSB3b3JkO1xuICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCByZXR1cm4gYW4gYXJyYXkgb2Ygb2JqZWN0c1xuICAgIGlmICh3b3JkLmxlbmd0aCA+IDEpIHJldHVybiB3b3JkLm1hcChpdGVtID0+IG5ldyBXb3JkKC4uLml0ZW0pKTtcblxuICAgIC8vIGlmIGFyZ3VtZW50IGlzIGEgc2luZ2xlIHN0cmluZyBkZXN0cnVjdHVyZSB0aGUgYXJyYXkgYW5kIG91dHB1dCBhIHN0cmluZ1xuICAgIGNvbnN0IFtzaW5nbGVXb3JkXSA9IHdvcmQ7XG4gICAgLy8gbWFrZSBhIHNpbmdsZSBvYmplY3RcbiAgICByZXR1cm4gbmV3IFdvcmQoc2luZ2xlV29yZCk7XG4gIH07XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tQVJSQVkgSVRFUkFUT1IgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIGxvb3AgdGhyb3VnaCBhcnJheSBvZiB3b3JkcyBhbmQgZXhlY3V0ZSBjYWxsYmFjayBmdW5jdGlvbiB1c2luZyByZWN1cnNpdmUgZnVuY3Rpb25cbiAgY29uc3QgYXJyYXlJdGVyYXRvciA9ICh3b3JkTGlzdCwgY2IpID0+IHtcbiAgICBjb25zdCBbYSwgLi4uYl0gPSB3b3JkTGlzdDtcbiAgICBjYihhKTtcbiAgICBpZiAod29yZExpc3QubGVuZ3RoID09PSAxKSByZXR1cm47XG4gICAgYXJyYXlJdGVyYXRvcihiLCBjYik7XG4gIH07XG5cbiAgbmFtZXNwYWNlLmFycmF5SXRlcmF0b3IgPSBhcnJheUl0ZXJhdG9yO1xuXG4gIC8vIFRoaXMgbWV0aG9kIHRha2VzIGluIGEgc3RyaW5nIGFuZCBvdXRwdXRzIGEgc3RyaW5nIG9mIHVuZGVyc2NvcmVzXG4gIC8vIHByb3BvcnRpb25hdGUgdG8gdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbnRhaW5lZCBpbiB0aGUgc3RyaW5nXG4gIGNvbnN0IG1ha2VEYXNoZXMgPSAoYW5zd2VyKSA9PiB7XG4gICAgY29uc3QgZGFzaGVkID0gW107XG4gICAgKGZ1bmN0aW9uIGxvb3BlcihhbnN3ZXIpIHtcbiAgICAgIGNvbnN0IFthLCAuLi5iXSA9IFsuLi5hbnN3ZXJdO1xuXG4gICAgICBkYXNoZWQucHVzaCgnXycpO1xuICAgICAgaWYgKGFuc3dlci5sZW5ndGggPT09IDEpIHJldHVybjtcbiAgICAgIGxvb3BlcihiKTtcbiAgICB9KGFuc3dlcikpO1xuICAgIHJldHVybiBkYXNoZWQuam9pbignJyk7XG4gIH07XG5cbiAgbmFtZXNwYWNlLm1ha2VEYXNoZXMgPSBtYWtlRGFzaGVzO1xuXG4gIC8vIHRoaXMgaXMgYSBtZXRob2QgdXNlZCBmb3IgRE9NIG1hbmlwdWxhdGlvblxuICAvLyB0aGUgbmFtZXMgb2YgdGhlIGZ1bmN0aW9ucyB3aXRoaW4gaXQgYm9ycm93IGZyb20galF1ZXJ5XG4gIGNvbnN0IG1ha2VFbGVtID0gKGVsZW1OYW1lID0gJ2RpdicpID0+IHtcbiAgICBjb25zdCBlbGVtID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoKGVsZW1OYW1lKSk7XG5cbiAgICAvLyBpbnNlcnQgZWxlbWVudCBpbnRvIGFub3RoZXIgZWxlbWVudFxuICAgIGVsZW0uYXBwZW5kVG8gPSAocGFyZW50KSA9PiB7XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbSk7XG4gICAgICByZXR1cm4gZWxlbTtcbiAgICB9O1xuXG4gICAgLy8gYWRkIHRleHQgdG8gZWxlbWVudFxuICAgIGVsZW0udGV4dCA9ICh0ZXh0KSA9PiB7XG4gICAgICBlbGVtLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgIHJldHVybiBlbGVtO1xuICAgIH07XG5cbiAgICAvLyBhZGQgSFRNTCB0byBlbGVtZW50XG4gICAgZWxlbS5odG1sID0gKGh0bWwpID0+IHtcbiAgICAgIGVsZW0uaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIHJldHVybiBlbGVtO1xuICAgIH07XG5cbiAgICAvLyBlbXB0eSB0aGUgZWxlbWVudCBvZiBhbGwgaXQncyBjb250ZW50XG4gICAgZWxlbS5lbXB0eSA9ICgpID0+IHtcbiAgICAgIGVsZW0uaW5uZXJIVE1MID0gJyc7XG4gICAgICByZXR1cm4gZWxlbTtcbiAgICB9O1xuXG4gICAgLy8gaGlkZSB0aGUgZWxlbWVudFxuICAgIGVsZW0uaGlkZSA9ICgpID0+IHtcbiAgICAgIGVsZW0uc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgcmV0dXJuIGVsZW07XG4gICAgfTtcblxuICAgIC8vIHNob3cgZWxlbWVudFxuICAgIGVsZW0uc2hvdyA9ICgpID0+IHtcbiAgICAgIGVsZW0uc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgIHJldHVybiBlbGVtO1xuICAgIH07XG5cbiAgICAvLyBhZGQgQ1NTIGNsYXNzIHRvIGVsZW1lbnRcbiAgICBlbGVtLmFkZENsYXNzID0gKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgZWxlbS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICByZXR1cm4gZWxlbTtcbiAgICB9O1xuXG4gICAgLy8gcmVtb3ZlIENTUyBjbGFzcyBmcm9tIGVsZW1lbnRcbiAgICBlbGVtLnJlbW92ZUNsYXNzID0gKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgZWxlbS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICByZXR1cm4gZWxlbTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGVsZW07XG4gIH07XG5cbiAgbmFtZXNwYWNlLm1ha2VFbGVtID0gbWFrZUVsZW07XG5cbiAgLy8gdGhpcyB0YWtlcyBpbiB0d28gYXJndW1lbnRzLCB0aGUgYW5zd2VyIGFuZCB0aGUgdXNlcidzIGd1ZXNzXG4gIC8vIGlmIHRoZSBsZXR0ZXIgZ3Vlc3MgaXMgcHJlc2VudCBpbiB0aGUgYW5zd2VyIGl0IG91dHB1dHMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHRoZVxuICAvLyBsZXR0ZXIgYXMgYSBzdHJpbmcgYW5kIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgbGV0dGVyIGlzIHByZXNlbnQgaW4gdGhlIGFuc3dlciBzdHJpbmdcbiAgY29uc3QgZ3Vlc3NlcyA9IChhbnN3ZXIsIGxldHRlckd1ZXNzZWQpID0+IChcbiAgICAvLyBzcHJlYWQgdGhlIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZyBhbmQgcGxhY2UgdGhlbSBpbiBhbiBhcnJheVxuICAgIC8vIHRoZW4gaXRlcmF0ZSB0aHJvdWdoIHRoZW0gdXNpbmcgdGhlIHJlZHVjZSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgYXJyYXkgdGhhdCBjb250YWluc1xuICAgIC8vIGFsbCB0aGUgbGV0dGVyIGd1ZXNzZWQgYW5kIHRoZSB0aGUgaW5kZXggYXQgd2hpY2ggaXQgaXMgbWF0Y2hlZCBpbiB0aGUgYW5zd2VycyBzdHJpbmdcbiAgICBbLi4uYW5zd2VyXS5yZWR1Y2UoKGFyciwgbGV0dGVyLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGxldHRlckd1ZXNzZWQgPT09IGxldHRlcikge1xuICAgICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgICAga2V5OiBsZXR0ZXJHdWVzc2VkLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICB9O1xuICAgICAgICBhcnIucHVzaChvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9LCBbXSlcbiAgKTtcblxuICBuYW1lc3BhY2UuZ3Vlc3NlcyA9IGd1ZXNzZXM7XG5cbiAgLy8gcmVwbGFjZXMgY2hhcmFjdGVycyBpbiBhIHN0cmluZyB3aGVyZSB3aXRoIHByb3ZpZGVkIHJlcGxhY2VtZW50IGNoYXJhY3RlciBcbiAgLy8gYW5kIGluZGV4IHdoZXJlIGl0IHNob3VsZCBiZSBwbGFjZWRcbiAgLy8gaXQgcmVjZWl2ZXMgdHdvIGFyZ3VtZW50cywgYSBzdHJpbmcgYW5kIGFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyBcbiAgLy8gYSBjaGFyYWN0ZXIgdGhlIHVzZXIgZ3Vlc3NlZCBhbmQgaXQncyBpbmRleCBpbiB0aGUgYW5zd2VyXG4gIC8vIGFsbCBjaGFyYWN0ZXJzIHByb3ZpZGVkIGFyZSBjb250YWluZWQgaW4gdGhlIGFuc3dlclxuICBjb25zdCByZXBsYWNlID0gKHdvcmQsIGlucHV0KSA9PiB7XG4gICAgY29uc3QgcmVzdWx0U3RyID0gaW5wdXQucmVkdWNlKChwcmV2aW91cywgZ3Vlc3MpID0+IHtcbiAgICAgIC8vIGluc2VydCBlYWNoIGxldHRlciBhY2NvcmRpbmcgdG8gaXQncyBwcm92aWRlZCBpbmRleFxuICAgICAgaWYgKGd1ZXNzLmluZGV4ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHByZXZpb3VzLnN1YnN0cmluZygwLCBndWVzcy5pbmRleCkgK1xuICAgICAgICAgIGd1ZXNzLmtleSArXG4gICAgICAgICAgcHJldmlvdXMuc3Vic3RyaW5nKGd1ZXNzLmluZGV4ICsgMSwgcHJldmlvdXMubGVuZ3RoKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sIHdvcmQpO1xuXG4gICAgLy8gcmV0dXJuIGFsdGVyZWQgc3RyaW5nIGFzIG91dHB1dFxuICAgIHJldHVybiByZXN1bHRTdHI7XG4gIH07XG5cbiAgbmFtZXNwYWNlLnJlcGxhY2UgPSByZXBsYWNlO1xuXG4gIC8vIHRha2VzIGluIGEgbnVtYmVyIGluY3JlbWVudHMgaXQgYnkgb25lIGFuZCByZXR1cm5zIHRoZSBpbmNyZW1lbnRlZCBudW1iZXJcbiAgY29uc3QgaW5jID0gKG51bSA9IC0xKSA9PiBudW0gKyAxO1xuXG4gIG5hbWVzcGFjZS5pbmMgPSBpbmM7XG59KShIQU5HTUFOKTtcblxuY29uc3QgZ2FtZVdvcmRzID0gSEFOR01BTi53b3JkRmFjdG9yeShbXG4gIFsnYm94ZXInLCAnSXQgY291bGQgYmUgYSBtYW4gb3IgYSBkb2cuJ10sXG4gIFsnY29tcGxpbWVudCcsICdTYXkgc29tZXRoaW5nIHRvIG1ha2UgbWUgc21pbGUuJ10sXG4gIFsnYmFza2V0YmFsbCcsICdOb3RoaW5nIGJ1dCBuZXQuJ10sXG4gIFsnaGliZXJuYXRlJywgJ0kgY2FuIGJhcmUgdGhlIGNvbGQuJ10sXG5dLCk7XG5jb25zdCB7XG4gIG1ha2VFbGVtLCBtYWtlRGFzaGVzLCBndWVzc2VzLCByZXBsYWNlLCBpbmMsXG59ID0gSEFOR01BTjtcbmNvbnN0IG1ldGhvZHNBcnIgPSBbbWFrZUVsZW0sIG1ha2VEYXNoZXMsIGd1ZXNzZXMsIHJlcGxhY2UsIGluY107XG5cbmNvbnN0IGdhbWVDb25maWcgPSAod29yZHMsIG1ldGhvZHMpID0+IHtcbiAgY29uc3QgW21ha2VFbGVtLCBtYWtlRGFzaGVzLCBndWVzc2VzLCByZXBsYWNlLCBpbmNdID0gbWV0aG9kcztcblxuICAvLyBjcmVhdGUgYW5kIHBsYWNlIGVsZW1lbnRzIGludG8gRE9NIHdoZW4gZ2FtZSBpbmludGFsbHkgc3RhcnRzXG4gIGNvbnN0IGdhbWUgPSBtYWtlRWxlbSgpXG4gICAgLmFkZENsYXNzKCdnYW1lJylcbiAgICAuYXBwZW5kVG8oZ2xvYmFsLmRvY3VtZW50LmJvZHkpO1xuXG4gIGNvbnN0IGRpc3BsYXlIZWFkU2NvcmUgPSBtYWtlRWxlbSgpXG4gICAgLmFkZENsYXNzKCdkaXNwbGF5X19oZWFkaW5nJylcbiAgICAuYWRkQ2xhc3MoJ2Rpc3BsYXlfX2hlYWRpbmctLXNjb3JlJylcbiAgICAuYXBwZW5kVG8oZ2FtZSk7XG5cbiAgY29uc3QgZGlzcGxheUNvbnRlbnRXb3JkID0gbWFrZUVsZW0oKVxuICAgIC5hZGRDbGFzcygnZGlzcGxheV9fY29udGVudCcpXG4gICAgLmFkZENsYXNzKCdkaXNwbGF5X19jb250ZW50LS13b3JkJylcbiAgICAuYXBwZW5kVG8oZ2FtZSk7XG5cbiAgY29uc3Qgd3JvbmdHdWVzc2VzRGl2ID0gbWFrZUVsZW0oKVxuICAgIC5hZGRDbGFzcygnd3JvbmctZ3Vlc3NlcycpXG4gICAgLmFwcGVuZFRvKGdhbWUpO1xuXG4gIGNvbnN0IGRpc3BsYXlIZWFkSGludCA9IG1ha2VFbGVtKCk7XG5cbiAgZGlzcGxheUhlYWRIaW50XG4gICAgLmFkZENsYXNzKCdnYW1lX19oaW50LWhlYWQnKVxuICAgIC5hZGRDbGFzcygnZGlzcGxheV9faGVhZGluZycpXG4gICAgLmFkZENsYXNzKCdkaXNwbGF5X19oZWFkaW5nLS1oaW50JylcbiAgICAuYXBwZW5kVG8oZ2FtZSlcbiAgICAudGV4dCgnSGludCcpO1xuXG4gIGNvbnN0IGRpc3BsYXlDb250ZW50SGludCA9IG1ha2VFbGVtKClcbiAgICAuYWRkQ2xhc3MoJ2Rpc3BsYXlfX2NvbnRlbnQnKVxuICAgIC5hZGRDbGFzcygnZGlzcGxheV9fY29udGVudC0taGludCcpXG4gICAgLmh0bWwoYDxwIGNsYXNzPVwiZ2FtZS10ZXh0IGhpbnQtdGV4dFwiPiR7d29yZHNbMF0uaGludH08L3A+YClcbiAgICAuYXBwZW5kVG8oZ2FtZSk7XG5cbiAgY29uc3QgeyBib2R5IH0gPSBnbG9iYWwuZG9jdW1lbnQ7XG5cbiAgLy8gc2V0IGluaXRpYWwgdmFsdWVzIGZvciBnYW1lXG5cbiAgbGV0IGlucHV0ID0gW107XG5cbiAgLy8gdGhpcyBzZXRzIHRoZSBjb3VudCB0byB6ZXJvXG4gIC8vIHRoZSBpbmMgZnVuY3Rpb24gcmV0dXJucyB6ZXJvIHdoZW4gaXQgaXMgcGFzc2VkIG5vIGFyZ3VtZW50c1xuICAvLyBvdGhlcndpc2UgaXQgdGFrZXMgYSBudW1iZXIgYXMgYW4gYXJndW1lbnQgYW5kIHR1cm5zIHRoYXQgbnVtYmVyIGluY3JlbWVudGVkIGJ5IDFcbiAgLy8gaW5jKDUpIGlzIDUgKyAxLCB3aGljaCByZXR1cm5zIDYuXG5cbiAgbGV0IGNvdW50ID0gaW5jKCk7XG5cbiAgbGV0IHsgd29yZCB9ID0gd29yZHNbY291bnRdO1xuXG4gIGxldCB3aW5zID0gMDtcblxuICBsZXQgY2hhbmNlcyA9IDU7XG5cbiAgbGV0IGd1ZXNzZWRMZXR0ZXJzID0gW107XG5cbiAgbGV0IHB1enpsZVdvcmQgPSBtYWtlRGFzaGVzKHdvcmQpO1xuXG4gIC8vICMjIyMjIyMjIyMjIyBTRVRUSU5HIElOSVRJQUwgRE9NIEVMRU1FTlRTICMjIyMjIyMjIyMjIyMjI1xuICBjb25zdCB3aW5zRGl2ID0gbWFrZUVsZW0oKVxuICAgIC5hZGRDbGFzcygnZ2FtZV9fc2NvcmUtLXdpbnMnKVxuICAgIC5odG1sKGB3aW5zOiA8c3BhbiBjbGFzcz1cImdhbWVfX3Njb3JlLS10YWxseVwiPiR7d2luc308L3NwYW4+YClcbiAgICAuYXBwZW5kVG8oZGlzcGxheUhlYWRTY29yZSk7XG4gIGNvbnN0IGNoYW5jZXNEaXYgPSBtYWtlRWxlbSgpXG4gICAgLmFkZENsYXNzKCdnYW1lX19zY29yZS0tY2hhbmNlcycpXG4gICAgLmh0bWwoYGNoYW5jZXM6IDxzcGFuIGNsYXNzPVwiZ2FtZV9fc2NvcmUtLXRhbGx5XCI+JHtjaGFuY2VzfTwvc3Bhbj5gKVxuICAgIC5hcHBlbmRUbyhkaXNwbGF5SGVhZFNjb3JlKTtcblxuICBjb25zdCB3b3JkUHJvZ3Jlc3NEaXYgPSBtYWtlRWxlbSgpXG4gICAgLmFkZENsYXNzKCdnYW1lLXRleHQnKVxuICAgIC5hZGRDbGFzcygnZGlzcGxheV9fY29udGVudC0tdGV4dCcpXG4gICAgLmh0bWwocHV6emxlV29yZClcbiAgICAuYXBwZW5kVG8oZGlzcGxheUNvbnRlbnRXb3JkKTtcblxuICBjb25zdCBtb2RhbEJhY2tkcm9wID0gbWFrZUVsZW0oKVxuICAgIC5hZGRDbGFzcygnbW9kYWxfX2JhY2tkcm9wJylcbiAgICAuaGlkZSgpXG4gICAgLmFwcGVuZFRvKGJvZHkpO1xuICBjb25zdCBtb2RhbCA9IG1ha2VFbGVtKClcbiAgICAuYWRkQ2xhc3MoJ21vZGFsJylcbiAgICAuYXBwZW5kVG8obW9kYWxCYWNrZHJvcCk7XG5cbiAgY29uc3QgbW9kYWxNZXNzYWdlID0gbWFrZUVsZW0oKVxuICAgIC5hZGRDbGFzcygnbW9kYWwtLW1lc3NhZ2UnKVxuICAgIC5hcHBlbmRUbyhtb2RhbCk7XG5cbiAgbGV0IGNhbkluY1Njb3JlcyA9IHRydWU7XG4gIGxldCBhY2tub3dsZWRnZUd1ZXNzZXMgPSB0cnVlO1xuXG4gIGNvbnN0IHNvZnRSZXNldCA9ICgpID0+IHtcbiAgICBndWVzc2VkTGV0dGVycyA9IFtdO1xuICAgIGNvdW50ID0gaW5jKGNvdW50KTtcbiAgICB3b3JkID0gd29yZHNbY291bnRdLndvcmQ7XG4gICAgcHV6emxlV29yZCA9IG1ha2VEYXNoZXMod29yZCk7XG4gICAgaW5wdXQgPSBbXTtcbiAgICBjaGFuY2VzID0gNTtcbiAgICB3b3JkUHJvZ3Jlc3NEaXYudGV4dChgV29yZCBzbyBmYXI6ICR7cHV6emxlV29yZH1gKTtcbiAgICAvLyBwcmludCBoaW50IHRvIHNjcmVlblxuICAgIGRpc3BsYXlDb250ZW50SGludC5odG1sKGA8cCBjbGFzcz1cImdhbWUtdGV4dCBoaW50LXRleHRcIj4ke3dvcmRzW2NvdW50XS5oaW50fTwvcD5gKVxuICAgICAgLmFkZENsYXNzKCdkaXNwbGF5X19jb250ZW50Jyk7XG5cbiAgICB3cm9uZ0d1ZXNzZXNEaXYuZW1wdHkoKTtcbiAgfTtcblxuICAvLyBSRVNUQVJUUyBHQU1FIC0tIFNUQVJUUyBGUk9NIFRIRSBCRUdJTk5JTkdcbiAgY29uc3QgaGFyZFJlc2V0ID0gKCkgPT4ge1xuICAgIGd1ZXNzZWRMZXR0ZXJzID0gW107XG4gICAgY2FuSW5jU2NvcmVzID0gdHJ1ZTtcbiAgICBjb3VudCA9IGluYygpO1xuICAgIHdvcmQgPSB3b3Jkc1tjb3VudF0ud29yZDtcbiAgICBwdXp6bGVXb3JkID0gbWFrZURhc2hlcyh3b3JkKTtcbiAgICBpbnB1dCA9IFtdO1xuICAgIGNoYW5jZXMgPSA1O1xuICAgIHdpbnMgPSAwO1xuICAgIHdvcmRQcm9ncmVzc0Rpdi5odG1sKHB1enpsZVdvcmQpO1xuICAgIC8vIHByaW50IGhpbnQgdG8gc2NyZWVuXG4gICAgZGlzcGxheUNvbnRlbnRIaW50Lmh0bWwoYDxwIGNsYXNzPVwiZ2FtZS10ZXh0IGhpbnQtdGV4dFwiPiR7d29yZHNbY291bnRdLmhpbnR9PC9wPmApO1xuICAgIHdyb25nR3Vlc3Nlc0Rpdi5lbXB0eSgpO1xuICB9O1xuXG4gIC8vIENPTU1FTkNFIEdBTUUgV0hFTiBVU0VSIFBSRVNTRVMgVEhFIEVOVEVSIEtFWVxuICBib2R5Lm9ua2V5dXAgPSAoZSkgPT4ge1xuICAgIGNvbnN0IGlzQWxwaGFiZXQgPSBzdHIgPT4gL15bYS16QS1aKCldJC8udGVzdChzdHIpO1xuXG4gICAgLy8gY2FwdHVyZSBrZXkgc3Ryb2tlXG4gICAgbGV0IHsga2V5LCBjdHJsS2V5IH0gPSBlO1xuXG5cbiAgICAvLyBpZiBrZXkgaXMgYSBsZXR0ZXIgdHVybiBpdCB0byBsb3dlciBjYXNlIGFuZCByZWFzc2lnbiBpdCB0byBiYWNrIHRvIGtleVxuICAgIGlmIChpc0FscGhhYmV0KGtleSkpIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gb25seSBwcmVjZWRlIGlmIENUUkwgaXNuJ3QgcHJlc3NlZCBhbG9uZyB3aXRoIGFscGhhYmV0IGtleVxuICAgIGlmIChjdHJsS2V5KSByZXR1cm47XG5cbiAgICAvL1xuICAgIGNvbnN0IHVzZXJHdWVzcyA9IGd1ZXNzZXMod29yZCwga2V5KTtcblxuICAgIC8vIHRoaXMgZnVuY3Rpb24gdGVzdHMgdGhlIGtleSBlbnRlcmVkIHRvIGZpbmQgb3V0IGlmIGl0IGlzIGFuIGFscGhhYmV0aWNhbCBjaGFyYWN0ZXJcbiAgICBjb25zdCBhbHBoYWJldFRlc3RQYXN0ID0gaXNBbHBoYWJldChrZXkpO1xuXG4gICAgLy8gc3ByZWFkIGFycmF5IGFuZCBwdXNoIHRoZW0gaW50byB0aGUgaW5wdXQgYXJyYXlcbiAgICBpZiAoYWNrbm93bGVkZ2VHdWVzc2VzKSBpbnB1dC5wdXNoKC4uLnVzZXJHdWVzcyk7XG5cbiAgICBwdXp6bGVXb3JkID0gcmVwbGFjZShwdXp6bGVXb3JkLCBpbnB1dCk7XG5cblxuICAgIC8vICMjIyMjIyMjIyMjIyMjIFVTRVIgR1VFU1NFRCBXUk9ORyAjIyMjIyMjIyMjIyMjXG4gICAgaWYgKFxuICAgICAgIXdvcmRzW2NvdW50XS5pc0luY2x1ZGVkKGtleSkgJiZcbiAgICAgIGNhbkluY1Njb3JlcyA9PT0gdHJ1ZSAmJlxuICAgICAgY2hhbmNlcyA+PSAxICYmXG4gICAgICBhbHBoYWJldFRlc3RQYXN0ICYmXG4gICAgICAhZ3Vlc3NlZExldHRlcnMuaW5jbHVkZXMoa2V5KVxuICAgICkge1xuICAgICAgY2hhbmNlcy0tO1xuICAgICAgZ3Vlc3NlZExldHRlcnMucHVzaChrZXkpO1xuICAgICAgbWFrZUVsZW0oKVxuICAgICAgICAuYWRkQ2xhc3MoJ3dyb25nLWxldHRlcicpXG4gICAgICAgIC50ZXh0KGtleSlcbiAgICAgICAgLmFwcGVuZFRvKHdyb25nR3Vlc3Nlc0Rpdik7XG5cbiAgICAgIHdyb25nR3Vlc3Nlc0RpdlxuICAgICAgICAuYWRkQ2xhc3MoJ3dpZ2dsZS1hbmltYXRpb24nKTtcblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHdyb25nR3Vlc3Nlc0RpdlxuICAgICAgICAgIC5yZW1vdmVDbGFzcygnd2lnZ2xlLWFuaW1hdGlvbicpO1xuICAgICAgfSwgMTAwMCk7XG4gICAgfVxuXG4gICAgLy8gIyMjIyMjIyMjIyBVU0VSIEVYSEFVU1RTIEFMTCBISVMgR1VFU1NFUyAjIyMjIyMjIyMjIyMjI1xuICAgIGlmICghY2hhbmNlcykge1xuICAgICAgYWNrbm93bGVkZ2VHdWVzc2VzID0gZmFsc2U7XG4gICAgICAvLyBhbGVydCgnWW91IGxvc3QhJyk7XG4gICAgICAvLyBjb3VudCA9IGluYygpO1xuICAgICAgbW9kYWxNZXNzYWdlLmh0bWwoYDxzcGFuIGNsYXNzPVwibW9kYWxfX2hlYWRpbmctLWxvc3NcIj5Zb3UgbG9zZSE8L3NwYW4+IFxuICAgICAgICAgICAgPGJyPiBcbiAgICAgICAgICAgIFRoZSB3b3JkIHdhcyA8c3BhbiBjbGFzcz1cIm1vZGFsX19ub3RhYmxlLS1sb3NzXCI+XCIke3dvcmRzW2NvdW50XS53b3JkfVwiPC9zcGFuPlxuICAgICAgICAgICAgPGJyPlxuICAgICAgICAgICAgUHJlc3MgPHNwYW4gY2xhc3M9XCJtb2RhbF9fbm90YWJsZS0tbG9zc1wiPlwiRW50ZXJcIjwvc3Bhbj4gdG8gc3RhcnQgb3Zlci5gKTtcbiAgICAgIG1vZGFsQmFja2Ryb3Auc2hvdygpO1xuICAgICAgaWYgKGtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICBjb3VudCA9IGluYygpO1xuICAgICAgICB3aW5zID0gaW5jKCk7XG4gICAgICAgIG1vZGFsQmFja2Ryb3AuaGlkZSgpO1xuICAgICAgICB3cm9uZ0d1ZXNzZXNEaXYuZW1wdHkoKTtcbiAgICAgICAgYWNrbm93bGVkZ2VHdWVzc2VzID0gdHJ1ZTtcbiAgICAgICAgd29yZCA9IHdvcmRzW2NvdW50XS53b3JkO1xuICAgICAgICBwdXp6bGVXb3JkID0gbWFrZURhc2hlcyh3b3JkKTtcbiAgICAgICAgaW5wdXQgPSBbXTtcbiAgICAgICAgY2hhbmNlcyA9IDU7XG4gICAgICAgIHdvcmRQcm9ncmVzc0Rpdi5odG1sKHB1enpsZVdvcmQpO1xuICAgICAgICAvLyBwcmludCBoaW50IHRvIHNjcmVlblxuICAgICAgICBkaXNwbGF5Q29udGVudEhpbnQuaHRtbChgPHAgY2xhc3M9XCJnYW1lLXRleHQgaGludC10ZXh0XCI+JHt3b3Jkc1tjb3VudF0uaGludH08L3A+YCk7XG4gICAgICAgIHdpbnNEaXYuaHRtbChgd2luczogPHNwYW4gY2xhc3M9XCJnYW1lX19zY29yZS0tdGFsbHlcIj4ke3dpbnN9PC9zcGFuPmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHByaW50IGhpbnQgdG8gc2NyZWVuXG4gICAgZGlzcGxheUNvbnRlbnRIaW50Lmh0bWwoYDxwIGNsYXNzPVwiZ2FtZS10ZXh0IGhpbnQtdGV4dFwiPiR7d29yZHNbY291bnRdLmhpbnR9PC9wPmApO1xuXG4gICAgLy8gIyMjIyMjIyMjIyMjIyMjIyBVU0VSIEdPVCBBTEwgVEhFIExFVFRFUlMgIyMjIyMjIyMjIyMjIyMjXG4gICAgaWYgKHdvcmRzW2NvdW50XS5pc01hdGNoZWQocHV6emxlV29yZCkpIHtcbiAgICAgIGlmIChjYW5JbmNTY29yZXMpIHdpbnMrKztcbiAgICAgIGNhbkluY1Njb3JlcyA9IGZhbHNlO1xuICAgICAgd2luc0Rpdi5odG1sKGB3aW5zOiA8c3BhbiBjbGFzcz1cImdhbWVfX3Njb3JlLS10YWxseVwiPiR7d2luc308L3NwYW4+YCk7XG4gICAgICB3b3JkUHJvZ3Jlc3NEaXYudGV4dChgV29yZCBzbyBmYXI6ICR7cHV6emxlV29yZH1gKTtcbiAgICAgIC8vIHByaW50IGhpbnQgdG8gc2NyZWVuXG4gICAgICBkaXNwbGF5Q29udGVudEhpbnQuaHRtbChgPHAgY2xhc3M9XCJnYW1lLXRleHQgaGludC10ZXh0XCI+JHt3b3Jkc1tjb3VudF0uaGludH08L3A+YCk7XG4gICAgICAvLyBtb2RhbFdvcmREaXNwbGF5LnRleHQocHV6emxlV29yZCk7XG4gICAgICBtb2RhbE1lc3NhZ2UuaHRtbChgPGgyIGNsYXNzPVwibW9kYWxfX2hlYWRpbmctLXdpblwiPkNvbmdyYXR1bGF0aW9ucyE8L2gyPiBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICA8cCBjbGFzcz1cIm1vZGFsX19ub3RhYmxlXCI+WW91J3JlIGNvcnJlY3QuIFRoZSB3b3JkJ3MgPHNwYW4gY2xhc3M9XCJtb2RhbF9fbm90YWJsZS0td2luXCI+XCIke3B1enpsZVdvcmR9XCI8L3NwYW4+XG4gICAgICAgICAgICAgICAgUHJlc3MgPHNwYW4gY2xhc3M9XCJtb2RhbF9fbm90YWJsZS0td2luXCI+XCJFbnRlclwiPC9zcGFuPiB0byBhdHRlbXB0IHRoZSBuZXh0IHdvcmQuPC9wPmApO1xuICAgICAgbW9kYWxCYWNrZHJvcC5zaG93KCk7XG5cbiAgICAgIC8vICBwbGF5ZXIgY29tcGxldGVkIGV2ZXJ5IHdvcmQgLS0tLS1UT0RPLS0tLS1cbiAgICAgIGlmICh3aW5zID09PSB3b3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgbW9kYWxNZXNzYWdlLmh0bWwoYFxuICAgICAgICAgICAgICAgICAgICA8aDEgY2xhc3M9XCJtb2RhbF9faGVhZGluZy0td2luXCI+Q29uZ3JhdHVsYXRpb25zPC9oMT5cbiAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJtb2RhbC0tbWVzc2FnZVwiPllvdSd2ZSBmb3VuZCBhbGwgdGhlIHdvcmRzLiBQcmVzcyBFbnRlciB0byBvdmVyPC9wPlxuICAgICAgICAgICAgICAgICBgKTtcbiAgICAgIH1cblxuICAgICAgLy8gbW92ZSB0byBuZXh0IHdvcmQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGVudGVyXG4gICAgICBpZiAoa2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgIGNhbkluY1Njb3JlcyA9IHRydWU7XG4gICAgICAgIC8vICMjIyMjIyBVU0VSIEdPVCBBTEwgVEhFIFdPUkRTICMjIyMjIyMjXG4gICAgICAgIGlmICh3b3Jkc1tjb3VudF0gIT09IHdvcmRzW3dvcmRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgLy8gIHRvIG5leHQgd29yZCBhbmQgcmVzZXQgbmVnYXRpdmUgcmVjb3JkIHJlZ2FyZGluZyBlYXQgaW5kaXZpZHVhbCB3b3JkXG4gICAgICAgICAgc29mdFJlc2V0KCk7XG4gICAgICAgICAgbW9kYWxCYWNrZHJvcC5oaWRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhlIGdhbWUgcmVzZXRzIHdoZW4gYWxsIHRoZSB3b3JkcyBoYXZlIGJlZW4gc29sdmVkXG4gICAgICAgICAgaGFyZFJlc2V0KCk7XG4gICAgICAgICAgbW9kYWxCYWNrZHJvcC5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGFuY2VzRGl2Lmh0bWwoYGNoYW5jZXM6IDxzcGFuIGNsYXNzPVwiZ2FtZV9fc2NvcmUtLXRhbGx5XCI+JHtjaGFuY2VzfTwvc3Bhbj5gKTtcbiAgICB3aW5zRGl2Lmh0bWwoYHdpbnM6IDxzcGFuIGNsYXNzPVwiZ2FtZV9fc2NvcmUtLXRhbGx5XCI+JHt3aW5zfTwvc3Bhbj5gKTtcbiAgICB3b3JkUHJvZ3Jlc3NEaXYuaHRtbChwdXp6bGVXb3JkKTtcbiAgfTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT0gRVZFTlQgSEFORExFUiBGT1IgU1RBUlRJTkcgR0FNRT09PT09PT09PT09PT09PT09PT09PT09XG5jb25zdCBoYW5kbGVLZXlwcmVzcyA9IChlKSA9PiB7XG4gIGNvbnN0IHsga2V5LCB0YXJnZXQgfSA9IGU7XG5cbiAgY29uc3QgaW50cm8gPSBnbG9iYWwuZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmludHJvJyk7XG5cbiAgaWYgKGtleSA9PT0gJ0VudGVyJykge1xuICAgIGdhbWVDb25maWcoZ2FtZVdvcmRzLCBtZXRob2RzQXJyKTtcbiAgICBpbnRyby5jbGFzc0xpc3QuYWRkKCdpbnRyby0tcmVtb3ZlJyk7XG5cbiAgICAvLyByZW1vdmUgbGlzdGVuZXIgc28gdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgcnVuIG9uY2UsIFxuICAgIC8vIHdoZW4gdGhlIHVzZXIgaW5pdGlhbGx5IGNvbWVzIHRvIHRoZSBzaXRlXG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgaGFuZGxlS2V5cHJlc3MpO1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUtleXByZXNzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaGFuZGxlQ2xpY2soZSkge1xuICBjb25zdCB7IHRhcmdldCB9ID0gZTtcblxuICBjb25zdCBpbnRybyA9IGdsb2JhbC5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW50cm8nKTtcblxuICBpbnRyby5jbGFzc0xpc3QuYWRkKCdpbnRyby0tcmVtb3ZlJyk7XG4gIGdhbWVDb25maWcoZ2FtZVdvcmRzLCBtZXRob2RzQXJyKTtcblxuICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGljayk7XG4gIGdsb2JhbC5kb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgaGFuZGxlS2V5cHJlc3MpO1xufVxuXG5nbG9iYWwuZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGhhbmRsZUtleXByZXNzKTtcbmNvbnN0IGludHJvVGV4dCA9IGdsb2JhbC5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW50cm8tLXRleHQnKTtcbmludHJvVGV4dC5vbmNsaWNrID0gaGFuZGxlQ2xpY2s7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2FwcC5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhCQTtBQUNBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBS0E7QUFJQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\n} catch(e) {\n\t// This works if the window reference is available\n\tif(typeof window === \"object\")\n\t\tg = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/MzY5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XG59IGNhdGNoKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcblx0XHRnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zdHlsZS9tYWluLnNjc3M/NDYwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3N0eWxlL21haW4uc2Nzc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n");

/***/ })
/******/ ]);