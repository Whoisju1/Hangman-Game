/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__style_main_scss__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__style_main_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__style_main_scss__);\n\n//import styles\n\n\n\nconst HANGMAN = {};\n\n// -------------------------NAMESPACE -------------------------\n(namespace => {\n\n    // -----------------------WORD CLASS------------------------\n    // used to make words for game\n    class Word {\n        constructor(word) {\n            this.word = word.toLowerCase();\n\n            this.isMatched = this.isMatched.bind(this);\n            this.isIncluded = this.isIncluded.bind(this);\n        }\n\n        // method to test if user letter choice is present in word\n        isIncluded(char) {\n            return this.word.includes(char.toLowerCase().trim());\n        }\n\n        //method to test if word is correct\n        isMatched(letters) {\n            return this.word === letters.toLowerCase().trim() ? true : false;\n        }\n    }\n\n    // ----------------------WORD FACTORY------------------------\n    // make single word or an array of words and make it a property of HANGMAN\n    // it takes an a single string, multiple stings, or an array of stings as an argument\n    HANGMAN.wordFactory = (...word) => {\n\n        // if argument is an array make it an array by destructuring it \n        if (Array.isArray(...word)) [word] = word;\n\n        // iterate through an array of strings and return an array of objects \n        if (word.length > 1) return word.map(item => new Word(item));\n\n        // if argument is a single string destructure the array and output a string\n        const [singleWord] = word;\n\n        // make a single object\n        return new Word(singleWord);\n    };\n\n    // ------------------ARRAY ITERATOR ----------------------------------\n\n    // loop through array of words and execute callback function using recursive function\n    const arrayIterator = (wordList, cb) => {\n        const [a, ...b] = wordList;\n        cb(a);\n        if (wordList.length === 1) return;\n        arrayIterator(b, cb);\n    };\n\n    HANGMAN.arrayIterator = arrayIterator;\n\n    // This method takes in a string and outputs a string of underscores\n    // proportionate to the number of characters contained in the string\n    const makeDashes = answer => {\n        let dashed = [];\n        (function looper(answer) {\n            let [a, ...b] = [...answer];\n\n            dashed.push(\"?\");\n            if (answer.length === 1) return;\n            looper(b);\n        })(answer);\n        return dashed.join('');\n    };\n\n    HANGMAN.makeDashes = makeDashes;\n\n    // this is a method used for DOM manipulation\n    // the names of the functions within it borrow from jQuery\n    const makeElem = elemName => {\n        let elem = document.createElement(elemName = 'div');\n\n        // insert element into another element\n        elem.appendTo = parent => {\n            parent.appendChild(elem);\n            return elem;\n        };\n\n        // add text to element\n        elem.text = text => {\n            elem.textContent = text;\n            return elem;\n        };\n\n        // add HTML to element\n        elem.html = html => {\n            elem.innerHTML = html;\n            return elem;\n        };\n\n        // empty the element of all it's content\n        elem.empty = () => {\n            elem.innerHTML = \"\";\n            return elem;\n        };\n\n        // hide the element\n        elem.hide = () => {\n            elem.style.visibility = \"hidden\";\n            return elem;\n        };\n\n        // show element\n        elem.show = () => {\n            elem.style.visibility = \"visible\";\n            return elem;\n        };\n\n        // add CSS class to element\n        elem.addClass = className => {\n            elem.classList.add(className);\n            return elem;\n        };\n\n        // remove CSS class from element\n        elem.removeClass = className => {\n            elem.classList.remove(className);\n            return elem;\n        };\n\n        return elem;\n    };\n\n    HANGMAN.makeElem = makeElem;\n\n    // this takes in two arguments, the answer and the user's guess\n    // if the letter guess is present in the answer it outputs an array of objects with the \n    // letter as a string and the index at which the letter is present in the answer string\n    let guesses = (answer, letterGuessed) => {\n        return (\n            // spread the characters in the string and place them in an array \n            // then iterate through them using the reduce function which returns a array that contains \n            // all the letter guessed and the the index at which it is matched in the answers string\n            [...answer].reduce((arr, letter, index) => {\n\n                if (letterGuessed === letter) {\n                    let obj = {\n                        key: letterGuessed,\n                        index: index\n                    };\n                    arr.push(obj);\n                }\n                return arr;\n            }, [])\n        );\n    };\n\n    HANGMAN.guesses = guesses;\n\n    // replaces characters in a string where with provided replacement character and index where it should be placed\n    // it receives two arguments, a string and an array of objects containing a character the user guessed and it's index in the answer\n    // all characters provided are contained in the answer\n    const replace = (word, input) => {\n        let resultStr = input.reduce((previous, guess) => {\n            // insert each letter according to it's provided index\n            if (guess.index !== -1) return previous.substring(0, guess.index) + guess.key + previous.substring(guess.index + 1, previous.length);\n        }, word);\n\n        // return altered string as output\n        return resultStr;\n    };\n\n    HANGMAN.replace = replace;\n\n    // takes in a number increments it by one and returns the incremented number \n    const inc = (num = -1) => num + 1;\n\n    HANGMAN.inc = inc;\n})(HANGMAN);\n\nconst gameWords = HANGMAN.wordFactory(['one', 'compliment', 'deliberate', 'confidence', 'dynamic', 'javascript']);\nconst { makeElem, makeDashes, guesses, replace, inc } = HANGMAN;\nconst methodsArr = [makeElem, makeDashes, guesses, replace, inc];\n\nconst gameConfig = (words, methods) => {\n\n    const [makeElem, makeDashes, guesses, replace, inc] = methods;\n\n    // create and place elements into DOM\n    const game = makeElem().addClass(\"game\").appendTo(document.body);\n    const scoreDiv = makeElem().addClass(\"game__score\").appendTo(game);\n    const gameWordDiv = makeElem().addClass(\".game__word\").appendTo(game);\n    const wrgGuessesDiv = makeElem().addClass('.game__wrong-guesses').appendTo(game);\n\n    const body = document.body;\n\n    // set initial values for game\n\n    let input = [];\n\n    // this sets the count to zero\n    // the inc function returns zero when it is passed no arguments \n    // otherwise it takes a number as an argument and turns that number incremented by 1\n    // inc(5) is 5 + 1, which returns 6.\n\n    let count = inc();\n\n    let { word } = words[count];\n\n    let wins = 0;\n\n    let chances = 5;\n\n    let guessedLetters = [];\n\n    let puzzleWord = makeDashes(word);\n\n    let isModalOpen = false;\n\n    const toggleModal = elem => {\n        isModalOpen ? elem.addClass('.modal__backdrop') : elem.removeClass('modal__backdrop');\n    };\n\n    // ############ SETTING INITIAL DOM ELEMENTS ###############\n    let winsDiv = makeElem().addClass('game__score--wins').html(`wins: <span class=\"game__score--tally\">${wins}</span>`).appendTo(scoreDiv);\n    let chancesDiv = makeElem().addClass('game__score--chances').html(`chances: <span class=\"game__score--tally\">${chances}</span>`).appendTo(scoreDiv);\n    let wrongGuessesDiv = makeElem().addClass('wrong-guesses').appendTo(wrgGuessesDiv);\n    let wordProgressDiv = makeElem().addClass(\"game__word-progress\").text(puzzleWord).appendTo(gameWordDiv);\n\n    const modalBackdrop = makeElem().addClass('modal__backdrop').hide().appendTo(body);\n    const modal = makeElem().addClass('modal').appendTo(modalBackdrop);\n    // const modalWordDisplay = makeElem('h1').addClass('modal--word').appendTo(modal);\n    const modalMessage = makeElem().addClass('modal--message').appendTo(modal);\n    // let victory = false; // ~~~~~~~~ NO USE YET ~~~~~~~~~\n\n    let canIncScores = true;\n    let acknowledgeGuesses = true;\n\n    const softReset = () => {\n        guessedLetters = [];\n        count = inc(count);\n        word = words[count].word;\n        puzzleWord = makeDashes(word);\n        input = [];\n        chances = 5;\n        wordProgressDiv.text(`Word so far: ${puzzleWord}`);\n        wrongGuessesDiv.empty();\n    };\n\n    // RESTARTS GAME -- STARTS FROM THE BEGINNING\n    const hardReset = () => {\n        alert('Congratulations you have found all the words'); // TODO: this will be replaced\n        guessedLetters = [];\n        canIncScores = true;\n        count = inc();\n        word = words[count].word;\n        puzzleWord = makeDashes(word);\n        input = [];\n        chances = 5;\n        wins = 0;\n        wordProgressDiv.text(puzzleWord);\n        wrongGuessesDiv.empty();\n    };\n\n    // COMMENCE GAME WHEN USER PRESSES THE ENTER KEY\n    body.onkeyup = e => {\n        const isAlphabet = str => /^[a-zA-Z()]$/.test(str);\n\n        // capture key stroke\n        let { key } = e;\n\n        // if key is a letter turn it to lower case and reassign it to back to key\n        if (isAlphabet(key)) key = key.toLowerCase();\n\n        // \n        let userGuess = guesses(word, key);\n\n        // this function tests the key entered to find out if it is an alphabetical character \n        const alphabetTestPast = isAlphabet(key);\n\n        // spread array and push them into the input array\n        if (acknowledgeGuesses) input.push(...userGuess);\n\n        puzzleWord = replace(puzzleWord, input);\n\n        // ############## USER GUESSED WRONG #############\n        if (!words[count].isIncluded(key) && canIncScores === true && chances >= 1 && alphabetTestPast && !guessedLetters.includes(key)) {\n            chances--;\n            guessedLetters.push(key);\n            makeElem().addClass('wrong-letter').text(key).appendTo(wrongGuessesDiv);\n        }\n\n        // ########## USER EXHAUSTS ALL HIS GUESSES ##############\n        if (!chances) {\n            acknowledgeGuesses = false;\n            // alert('You lost!');\n            // count = inc();\n            modalMessage.html(`<span class=\"modal__heading--loss\">You lose!</span> \n            <br> \n            The word was <span class=\"modal__notable--loss\">\"${words[count].word}\"</span>\n            <br>\n            Press <span class=\"modal__notable--loss\">\"Enter\"</span> to start over.`);\n            modalBackdrop.show();\n            if (key === \"Enter\") {\n                count = inc();\n                modalBackdrop.hide();\n                wrongGuessesDiv.empty();\n                acknowledgeGuesses = true;\n                word = words[count].word;\n                puzzleWord = makeDashes(word);\n                input = [];\n                chances = 5;\n                wordProgressDiv.text(puzzleWord);\n            }\n        }\n\n        //  player completed every word -----TODO-----\n        // if (wins === words.length) {\n        //     alert('VICTORY!!!!!');\n        // }\n\n        // ################ USER GOT ALL THE LETTERS ###############\n        if (words[count].isMatched(puzzleWord)) {\n            if (canIncScores) wins++;\n            canIncScores = false;\n            winsDiv.html(`wins: <span class=\"game__score--tally\">${wins}</span>`);\n            wordProgressDiv.text(`Word so far: ${puzzleWord}`);\n\n            // modalWordDisplay.text(puzzleWord);\n            modalMessage.html(`<span class=\"modal__heading--win\">Congratulations!</span> \n                <br> \n                You're correct. The word's <span class=\"modal__notable--win\">\"${puzzleWord}\"</span>\n                <br>\n                Press <span class=\"modal__notable--win\">\"Enter\"</span> to attempt the next word.`);\n            modalBackdrop.show();\n\n            // move to next word when the user presses enter\n            if (key === \"Enter\") {\n                canIncScores = true;\n                // ###### USER GOT ALL THE WORDS ########\n                if (words[count] !== words[words.length - 1]) {\n                    //  to next word and reset negative record regarding eat individual word\n                    softReset();\n                    modalBackdrop.hide();\n                } else {\n                    // the game resets when all the words have been solved\n                    hardReset();\n                }\n            }\n        }\n\n        chancesDiv.html(`chances: <span class=\"game__score--tally\">${chances}</span>`);\n        wordProgressDiv.text(puzzleWord);\n    };\n};\n\n// =================== EVENT HANDLER FOR STARTING GAME=======================\nconst handleKeypress = e => {\n    const { key, target } = e;\n\n    const intro = document.querySelector('.intro');\n\n    if (key === 'Enter') {\n        gameConfig(gameWords, methodsArr);\n        intro.classList.add('intro--remove');\n\n        // remove listener so that this function is only run once, when the user initially comes to the site\n        target.removeEventListener('keypress', handleKeypress);\n    }\n};\n\ndocument.body.addEventListener(\"keypress\", handleKeypress);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvYXBwLmpzP2JkOWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vL2ltcG9ydCBzdHlsZXNcbmltcG9ydCAnLi9zdHlsZS9tYWluLnNjc3MnO1xuXG5jb25zdCBIQU5HTUFOID0ge307XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1OQU1FU1BBQ0UgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKG5hbWVzcGFjZSA9PiB7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVdPUkQgQ0xBU1MtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB1c2VkIHRvIG1ha2Ugd29yZHMgZm9yIGdhbWVcbiAgICBjbGFzcyBXb3JkIHtcbiAgICAgICAgY29uc3RydWN0b3Iod29yZCkge1xuICAgICAgICAgICAgdGhpcy53b3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmlzTWF0Y2hlZCA9IHRoaXMuaXNNYXRjaGVkLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmlzSW5jbHVkZWQgPSB0aGlzLmlzSW5jbHVkZWQuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1ldGhvZCB0byB0ZXN0IGlmIHVzZXIgbGV0dGVyIGNob2ljZSBpcyBwcmVzZW50IGluIHdvcmRcbiAgICAgICAgaXNJbmNsdWRlZChjaGFyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53b3JkLmluY2x1ZGVzKGNoYXIudG9Mb3dlckNhc2UoKS50cmltKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9tZXRob2QgdG8gdGVzdCBpZiB3b3JkIGlzIGNvcnJlY3RcbiAgICAgICAgaXNNYXRjaGVkKGxldHRlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndvcmQgPT09IGxldHRlcnMudG9Mb3dlckNhc2UoKS50cmltKCkgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tV09SRCBGQUNUT1JZLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gbWFrZSBzaW5nbGUgd29yZCBvciBhbiBhcnJheSBvZiB3b3JkcyBhbmQgbWFrZSBpdCBhIHByb3BlcnR5IG9mIEhBTkdNQU5cbiAgICAvLyBpdCB0YWtlcyBhbiBhIHNpbmdsZSBzdHJpbmcsIG11bHRpcGxlIHN0aW5ncywgb3IgYW4gYXJyYXkgb2Ygc3RpbmdzIGFzIGFuIGFyZ3VtZW50XG4gICAgSEFOR01BTi53b3JkRmFjdG9yeSA9ICguLi53b3JkKSA9PiB7XG5cbiAgICAgICAgLy8gaWYgYXJndW1lbnQgaXMgYW4gYXJyYXkgbWFrZSBpdCBhbiBhcnJheSBieSBkZXN0cnVjdHVyaW5nIGl0IFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSguLi53b3JkKSkgW3dvcmRdID0gd29yZDtcblxuICAgICAgICAvLyBpdGVyYXRlIHRocm91Z2ggYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgcmV0dXJuIGFuIGFycmF5IG9mIG9iamVjdHMgXG4gICAgICAgIGlmICh3b3JkLmxlbmd0aCA+IDEpIHJldHVybiB3b3JkLm1hcChpdGVtID0+IG5ldyBXb3JkKGl0ZW0pKTtcblxuICAgICAgICAvLyBpZiBhcmd1bWVudCBpcyBhIHNpbmdsZSBzdHJpbmcgZGVzdHJ1Y3R1cmUgdGhlIGFycmF5IGFuZCBvdXRwdXQgYSBzdHJpbmdcbiAgICAgICAgY29uc3QgW3NpbmdsZVdvcmRdID0gd29yZDtcblxuICAgICAgICAvLyBtYWtlIGEgc2luZ2xlIG9iamVjdFxuICAgICAgICByZXR1cm4gbmV3IFdvcmQoc2luZ2xlV29yZCk7XG4gICAgfTtcbiAgICBcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1BUlJBWSBJVEVSQVRPUiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBsb29wIHRocm91Z2ggYXJyYXkgb2Ygd29yZHMgYW5kIGV4ZWN1dGUgY2FsbGJhY2sgZnVuY3Rpb24gdXNpbmcgcmVjdXJzaXZlIGZ1bmN0aW9uXG4gICAgY29uc3QgYXJyYXlJdGVyYXRvciA9ICh3b3JkTGlzdCwgY2IpID0+IHtcbiAgICAgICAgY29uc3QgW2EsIC4uLmJdID0gd29yZExpc3Q7XG4gICAgICAgIGNiKGEpO1xuICAgICAgICBpZiAod29yZExpc3QubGVuZ3RoID09PSAxKSByZXR1cm47XG4gICAgICAgIGFycmF5SXRlcmF0b3IoYiwgY2IpO1xuICAgIH07XG5cbiAgICBIQU5HTUFOLmFycmF5SXRlcmF0b3IgPSBhcnJheUl0ZXJhdG9yO1xuXG4gICAgLy8gVGhpcyBtZXRob2QgdGFrZXMgaW4gYSBzdHJpbmcgYW5kIG91dHB1dHMgYSBzdHJpbmcgb2YgdW5kZXJzY29yZXNcbiAgICAvLyBwcm9wb3J0aW9uYXRlIHRvIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb250YWluZWQgaW4gdGhlIHN0cmluZ1xuICAgIGNvbnN0IG1ha2VEYXNoZXMgPSAoYW5zd2VyKSA9PiB7XG4gICAgICAgIGxldCBkYXNoZWQgPSBbXTtcbiAgICAgICAgKGZ1bmN0aW9uIGxvb3BlciAoYW5zd2VyKSB7XG4gICAgICAgICAgICBsZXQgW2EsIC4uLmJdID0gWy4uLmFuc3dlcl07XG5cbiAgICAgICAgICAgIGRhc2hlZC5wdXNoKFwiP1wiKTtcbiAgICAgICAgICAgIGlmIChhbnN3ZXIubGVuZ3RoID09PSAxKSByZXR1cm47XG4gICAgICAgICAgICBsb29wZXIgKGIpO1xuICAgICAgICB9KShhbnN3ZXIpO1xuICAgICAgICByZXR1cm4gZGFzaGVkLmpvaW4oJycpO1xuICAgIH07XG5cbiAgICBIQU5HTUFOLm1ha2VEYXNoZXMgPSBtYWtlRGFzaGVzO1xuXG4gICAgLy8gdGhpcyBpcyBhIG1ldGhvZCB1c2VkIGZvciBET00gbWFuaXB1bGF0aW9uXG4gICAgLy8gdGhlIG5hbWVzIG9mIHRoZSBmdW5jdGlvbnMgd2l0aGluIGl0IGJvcnJvdyBmcm9tIGpRdWVyeVxuICAgIGNvbnN0IG1ha2VFbGVtID0gKGVsZW1OYW1lKSA9PiB7XG4gICAgICAgIGxldCBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbGVtTmFtZSA9ICdkaXYnKTtcblxuICAgICAgICAvLyBpbnNlcnQgZWxlbWVudCBpbnRvIGFub3RoZXIgZWxlbWVudFxuICAgICAgICBlbGVtLmFwcGVuZFRvID0gcGFyZW50ID0+IHtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChlbGVtKTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgICB9O1xuICAgIFxuICAgICAgICAvLyBhZGQgdGV4dCB0byBlbGVtZW50XG4gICAgICAgIGVsZW0udGV4dCA9IHRleHQgPT4ge1xuICAgICAgICAgICAgZWxlbS50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgLy8gYWRkIEhUTUwgdG8gZWxlbWVudFxuICAgICAgICBlbGVtLmh0bWwgPSBodG1sID0+IHtcbiAgICAgICAgICAgIGVsZW0uaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgICB9O1xuICAgIFxuICAgICAgICAvLyBlbXB0eSB0aGUgZWxlbWVudCBvZiBhbGwgaXQncyBjb250ZW50XG4gICAgICAgIGVsZW0uZW1wdHkgPSAoKSA9PiB7XG4gICAgICAgICAgICBlbGVtLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgLy8gaGlkZSB0aGUgZWxlbWVudFxuICAgICAgICBlbGVtLmhpZGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBlbGVtLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIC8vIHNob3cgZWxlbWVudFxuICAgICAgICBlbGVtLnNob3cgPSAoKSA9PiB7XG4gICAgICAgICAgICBlbGVtLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcbiAgICAgICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFkZCBDU1MgY2xhc3MgdG8gZWxlbWVudFxuICAgICAgICBlbGVtLmFkZENsYXNzID0gKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICAgICAgZWxlbS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyByZW1vdmUgQ1NTIGNsYXNzIGZyb20gZWxlbWVudFxuICAgICAgICBlbGVtLnJlbW92ZUNsYXNzID0gKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICAgICAgZWxlbS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgfTtcblxuICAgIEhBTkdNQU4ubWFrZUVsZW0gPSBtYWtlRWxlbTtcblxuICAgIC8vIHRoaXMgdGFrZXMgaW4gdHdvIGFyZ3VtZW50cywgdGhlIGFuc3dlciBhbmQgdGhlIHVzZXIncyBndWVzc1xuICAgIC8vIGlmIHRoZSBsZXR0ZXIgZ3Vlc3MgaXMgcHJlc2VudCBpbiB0aGUgYW5zd2VyIGl0IG91dHB1dHMgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIHRoZSBcbiAgICAvLyBsZXR0ZXIgYXMgYSBzdHJpbmcgYW5kIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgbGV0dGVyIGlzIHByZXNlbnQgaW4gdGhlIGFuc3dlciBzdHJpbmdcbiAgICBsZXQgZ3Vlc3NlcyA9IChhbnN3ZXIsIGxldHRlckd1ZXNzZWQpID0+e1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLy8gc3ByZWFkIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgYW5kIHBsYWNlIHRoZW0gaW4gYW4gYXJyYXkgXG4gICAgICAgICAgICAvLyB0aGVuIGl0ZXJhdGUgdGhyb3VnaCB0aGVtIHVzaW5nIHRoZSByZWR1Y2UgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIGFycmF5IHRoYXQgY29udGFpbnMgXG4gICAgICAgICAgICAvLyBhbGwgdGhlIGxldHRlciBndWVzc2VkIGFuZCB0aGUgdGhlIGluZGV4IGF0IHdoaWNoIGl0IGlzIG1hdGNoZWQgaW4gdGhlIGFuc3dlcnMgc3RyaW5nXG4gICAgICAgICAgICBbLi4uYW5zd2VyXS5yZWR1Y2UoKGFyciwgbGV0dGVyLCBpbmRleCkgPT4geyBcblxuICAgICAgICAgICAgICAgIGlmIChsZXR0ZXJHdWVzc2VkID09PSBsZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9iaiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogbGV0dGVyR3Vlc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChvYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICAgICAgfSwgW10pXG4gICAgICAgICk7XG4gICAgfTtcblxuICAgIEhBTkdNQU4uZ3Vlc3NlcyA9IGd1ZXNzZXM7XG5cbiAgICAvLyByZXBsYWNlcyBjaGFyYWN0ZXJzIGluIGEgc3RyaW5nIHdoZXJlIHdpdGggcHJvdmlkZWQgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGFuZCBpbmRleCB3aGVyZSBpdCBzaG91bGQgYmUgcGxhY2VkXG4vLyBpdCByZWNlaXZlcyB0d28gYXJndW1lbnRzLCBhIHN0cmluZyBhbmQgYW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIGEgY2hhcmFjdGVyIHRoZSB1c2VyIGd1ZXNzZWQgYW5kIGl0J3MgaW5kZXggaW4gdGhlIGFuc3dlclxuLy8gYWxsIGNoYXJhY3RlcnMgcHJvdmlkZWQgYXJlIGNvbnRhaW5lZCBpbiB0aGUgYW5zd2VyXG4gICAgY29uc3QgcmVwbGFjZSA9ICh3b3JkLCBpbnB1dCkgPT4ge1xuICAgICAgICBsZXQgcmVzdWx0U3RyID0gaW5wdXQucmVkdWNlKChwcmV2aW91cywgZ3Vlc3MpID0+IHtcbiAgICAgICAgICAgIC8vIGluc2VydCBlYWNoIGxldHRlciBhY2NvcmRpbmcgdG8gaXQncyBwcm92aWRlZCBpbmRleFxuICAgICAgICAgICAgaWYoZ3Vlc3MuaW5kZXggIT09IC0xKSByZXR1cm4gcHJldmlvdXMuc3Vic3RyaW5nKDAsIGd1ZXNzLmluZGV4KSArIGd1ZXNzLmtleSArIHByZXZpb3VzLnN1YnN0cmluZyhndWVzcy5pbmRleCArIDEsIHByZXZpb3VzLmxlbmd0aCk7XG4gICAgICAgIH0sIHdvcmQpO1xuXG4gICAgICAgIC8vIHJldHVybiBhbHRlcmVkIHN0cmluZyBhcyBvdXRwdXRcbiAgICAgICAgcmV0dXJuIHJlc3VsdFN0cjtcbiAgICB9O1xuXG4gICAgSEFOR01BTi5yZXBsYWNlID0gcmVwbGFjZTtcblxuICAgIC8vIHRha2VzIGluIGEgbnVtYmVyIGluY3JlbWVudHMgaXQgYnkgb25lIGFuZCByZXR1cm5zIHRoZSBpbmNyZW1lbnRlZCBudW1iZXIgXG4gICAgY29uc3QgaW5jID0gKG51bSA9IC0xKSA9PiBudW0rMTtcblxuICAgIEhBTkdNQU4uaW5jID0gaW5jO1xuICAgIFxufSkoSEFOR01BTik7XG5cblxuY29uc3QgZ2FtZVdvcmRzID0gSEFOR01BTi53b3JkRmFjdG9yeShbJ29uZScsICdjb21wbGltZW50JywgJ2RlbGliZXJhdGUnLCAnY29uZmlkZW5jZScsICdkeW5hbWljJywgJ2phdmFzY3JpcHQnXSk7XG5jb25zdCB7bWFrZUVsZW0sIG1ha2VEYXNoZXMsIGd1ZXNzZXMsIHJlcGxhY2UsIGluY30gPSBIQU5HTUFOO1xuY29uc3QgbWV0aG9kc0FyciA9IFttYWtlRWxlbSwgbWFrZURhc2hlcywgZ3Vlc3NlcywgcmVwbGFjZSwgaW5jXTtcblxuY29uc3QgZ2FtZUNvbmZpZyA9ICh3b3JkcywgbWV0aG9kcykgPT4ge1xuXG4gICAgY29uc3QgW21ha2VFbGVtLCBtYWtlRGFzaGVzLCBndWVzc2VzLCByZXBsYWNlLCBpbmNdID0gbWV0aG9kcztcblxuICAgIC8vIGNyZWF0ZSBhbmQgcGxhY2UgZWxlbWVudHMgaW50byBET01cbiAgICBjb25zdCBnYW1lID0gbWFrZUVsZW0oKS5hZGRDbGFzcyhcImdhbWVcIikuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSk7XG4gICAgY29uc3Qgc2NvcmVEaXYgPSBtYWtlRWxlbSgpLmFkZENsYXNzKFwiZ2FtZV9fc2NvcmVcIikuYXBwZW5kVG8oZ2FtZSk7XG4gICAgY29uc3QgZ2FtZVdvcmREaXYgPSBtYWtlRWxlbSgpLmFkZENsYXNzKFwiLmdhbWVfX3dvcmRcIikuYXBwZW5kVG8oZ2FtZSk7XG4gICAgY29uc3Qgd3JnR3Vlc3Nlc0RpdiA9IG1ha2VFbGVtKCkuYWRkQ2xhc3MoJy5nYW1lX193cm9uZy1ndWVzc2VzJykuYXBwZW5kVG8oZ2FtZSk7XG5cbiAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICBcbiAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZXMgZm9yIGdhbWVcblxuICAgIGxldCBpbnB1dCA9IFtdO1xuXG4gICAgLy8gdGhpcyBzZXRzIHRoZSBjb3VudCB0byB6ZXJvXG4gICAgLy8gdGhlIGluYyBmdW5jdGlvbiByZXR1cm5zIHplcm8gd2hlbiBpdCBpcyBwYXNzZWQgbm8gYXJndW1lbnRzIFxuICAgIC8vIG90aGVyd2lzZSBpdCB0YWtlcyBhIG51bWJlciBhcyBhbiBhcmd1bWVudCBhbmQgdHVybnMgdGhhdCBudW1iZXIgaW5jcmVtZW50ZWQgYnkgMVxuICAgIC8vIGluYyg1KSBpcyA1ICsgMSwgd2hpY2ggcmV0dXJucyA2LlxuXG4gICAgbGV0IGNvdW50ID0gaW5jKCk7XG4gICAgXG4gICAgbGV0IHt3b3JkfT0gd29yZHNbY291bnRdO1xuXG4gICAgbGV0IHdpbnMgPSAwO1xuICAgIFxuICAgIGxldCBjaGFuY2VzID0gNTtcblxuICAgIGxldCBndWVzc2VkTGV0dGVycyA9IFtdO1xuXG4gICAgbGV0IHB1enpsZVdvcmQgPSBtYWtlRGFzaGVzKHdvcmQpO1xuXG4gICAgbGV0IGlzTW9kYWxPcGVuID0gZmFsc2U7XG5cbiAgICBjb25zdCB0b2dnbGVNb2RhbCA9IChlbGVtKSA9PiB7XG4gICAgICAgIChpc01vZGFsT3BlbikgPyBlbGVtLmFkZENsYXNzKCcubW9kYWxfX2JhY2tkcm9wJykgOiBlbGVtLnJlbW92ZUNsYXNzKCdtb2RhbF9fYmFja2Ryb3AnKVxuICAgIH07XG5cbiAgICBcbiAgICAvLyAjIyMjIyMjIyMjIyMgU0VUVElORyBJTklUSUFMIERPTSBFTEVNRU5UUyAjIyMjIyMjIyMjIyMjIyNcbiAgICBsZXQgd2luc0RpdiA9IG1ha2VFbGVtKCkuYWRkQ2xhc3MoJ2dhbWVfX3Njb3JlLS13aW5zJykuaHRtbChgd2luczogPHNwYW4gY2xhc3M9XCJnYW1lX19zY29yZS0tdGFsbHlcIj4ke3dpbnN9PC9zcGFuPmApLmFwcGVuZFRvKHNjb3JlRGl2KTtcbiAgICBsZXQgY2hhbmNlc0RpdiA9IG1ha2VFbGVtKCkuYWRkQ2xhc3MoJ2dhbWVfX3Njb3JlLS1jaGFuY2VzJykuaHRtbChgY2hhbmNlczogPHNwYW4gY2xhc3M9XCJnYW1lX19zY29yZS0tdGFsbHlcIj4ke2NoYW5jZXN9PC9zcGFuPmApLmFwcGVuZFRvKHNjb3JlRGl2KTtcbiAgICBsZXQgd3JvbmdHdWVzc2VzRGl2ID0gbWFrZUVsZW0oKS5hZGRDbGFzcygnd3JvbmctZ3Vlc3NlcycpLmFwcGVuZFRvKHdyZ0d1ZXNzZXNEaXYpO1xuICAgIGxldCB3b3JkUHJvZ3Jlc3NEaXYgPSBtYWtlRWxlbSgpXG4gICAgLmFkZENsYXNzKFwiZ2FtZV9fd29yZC1wcm9ncmVzc1wiKVxuICAgIC50ZXh0KHB1enpsZVdvcmQpXG4gICAgLmFwcGVuZFRvKGdhbWVXb3JkRGl2KTtcbiAgICBcbiAgICBjb25zdCBtb2RhbEJhY2tkcm9wID0gbWFrZUVsZW0oKS5hZGRDbGFzcygnbW9kYWxfX2JhY2tkcm9wJykuaGlkZSgpLmFwcGVuZFRvKGJvZHkpO1xuICAgIGNvbnN0IG1vZGFsID0gbWFrZUVsZW0oKS5hZGRDbGFzcygnbW9kYWwnKS5hcHBlbmRUbyhtb2RhbEJhY2tkcm9wKTtcbiAgICAvLyBjb25zdCBtb2RhbFdvcmREaXNwbGF5ID0gbWFrZUVsZW0oJ2gxJykuYWRkQ2xhc3MoJ21vZGFsLS13b3JkJykuYXBwZW5kVG8obW9kYWwpO1xuICAgIGNvbnN0IG1vZGFsTWVzc2FnZSA9IG1ha2VFbGVtKCkuYWRkQ2xhc3MoJ21vZGFsLS1tZXNzYWdlJykuYXBwZW5kVG8obW9kYWwpO1xuICAgIC8vIGxldCB2aWN0b3J5ID0gZmFsc2U7IC8vIH5+fn5+fn5+IE5PIFVTRSBZRVQgfn5+fn5+fn5+XG5cbiAgICBsZXQgY2FuSW5jU2NvcmVzID0gdHJ1ZTtcbiAgICBsZXQgYWNrbm93bGVkZ2VHdWVzc2VzID0gdHJ1ZTtcblxuICAgIGNvbnN0IHNvZnRSZXNldCA9ICgpID0+IHtcbiAgICAgICAgZ3Vlc3NlZExldHRlcnMgPSBbXTtcbiAgICAgICAgY291bnQgPSBpbmMoY291bnQpO1xuICAgICAgICB3b3JkID0gd29yZHNbY291bnRdLndvcmQ7XG4gICAgICAgIHB1enpsZVdvcmQgPSBtYWtlRGFzaGVzKHdvcmQpO1xuICAgICAgICBpbnB1dCA9IFtdOyAgICAgICAgXG4gICAgICAgIGNoYW5jZXMgPSA1O1xuICAgICAgICB3b3JkUHJvZ3Jlc3NEaXZcbiAgICAgICAgLnRleHQoYFdvcmQgc28gZmFyOiAke3B1enpsZVdvcmR9YCk7IFxuICAgICAgICB3cm9uZ0d1ZXNzZXNEaXYuZW1wdHkoKTsgIFxuICAgIH07XG5cbiAgICAvLyBSRVNUQVJUUyBHQU1FIC0tIFNUQVJUUyBGUk9NIFRIRSBCRUdJTk5JTkdcbiAgICBjb25zdCBoYXJkUmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIGFsZXJ0KCdDb25ncmF0dWxhdGlvbnMgeW91IGhhdmUgZm91bmQgYWxsIHRoZSB3b3JkcycpOyAvLyBUT0RPOiB0aGlzIHdpbGwgYmUgcmVwbGFjZWRcbiAgICAgICAgZ3Vlc3NlZExldHRlcnMgPSBbXTtcbiAgICAgICAgY2FuSW5jU2NvcmVzID0gdHJ1ZTtcbiAgICAgICAgY291bnQgPSBpbmMoKTtcbiAgICAgICAgd29yZCA9IHdvcmRzW2NvdW50XS53b3JkO1xuICAgICAgICBwdXp6bGVXb3JkID0gbWFrZURhc2hlcyh3b3JkKTtcbiAgICAgICAgaW5wdXQgPSBbXTsgIFxuICAgICAgICBjaGFuY2VzID0gNTsgICAgICBcbiAgICAgICAgd2lucyA9IDA7XG4gICAgICAgIHdvcmRQcm9ncmVzc0RpdlxuICAgICAgICAudGV4dChwdXp6bGVXb3JkKTsgXG4gICAgICAgIHdyb25nR3Vlc3Nlc0Rpdi5lbXB0eSgpO1xuICAgIH07XG5cbiAgICAvLyBDT01NRU5DRSBHQU1FIFdIRU4gVVNFUiBQUkVTU0VTIFRIRSBFTlRFUiBLRVlcbiAgICBib2R5Lm9ua2V5dXAgPSAoZSkgPT4ge1xuICAgICAgICBjb25zdCBpc0FscGhhYmV0ID0gc3RyID0+IC9eW2EtekEtWigpXSQvLnRlc3Qoc3RyKTtcbiAgICAgICAgICBcbiAgICAgICAgLy8gY2FwdHVyZSBrZXkgc3Ryb2tlXG4gICAgICAgIGxldCB7a2V5fSA9IGU7XG5cbiAgICAgICAgLy8gaWYga2V5IGlzIGEgbGV0dGVyIHR1cm4gaXQgdG8gbG93ZXIgY2FzZSBhbmQgcmVhc3NpZ24gaXQgdG8gYmFjayB0byBrZXlcbiAgICAgICAgaWYgKGlzQWxwaGFiZXQoa2V5KSkga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgLy8gXG4gICAgICAgIGxldCB1c2VyR3Vlc3MgPSBndWVzc2VzKHdvcmQsIGtleSk7XG5cbiAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiB0ZXN0cyB0aGUga2V5IGVudGVyZWQgdG8gZmluZCBvdXQgaWYgaXQgaXMgYW4gYWxwaGFiZXRpY2FsIGNoYXJhY3RlciBcbiAgICAgICAgY29uc3QgYWxwaGFiZXRUZXN0UGFzdCA9IGlzQWxwaGFiZXQoa2V5KTtcbiAgICAgICAgXG4gICAgICAgIC8vIHNwcmVhZCBhcnJheSBhbmQgcHVzaCB0aGVtIGludG8gdGhlIGlucHV0IGFycmF5XG4gICAgICAgIGlmIChhY2tub3dsZWRnZUd1ZXNzZXMpIGlucHV0LnB1c2goLi4udXNlckd1ZXNzKTtcbiAgICAgICAgXG4gICAgICAgIHB1enpsZVdvcmQgPSByZXBsYWNlKHB1enpsZVdvcmQsIGlucHV0KTtcblxuICAgICAgICAvLyAjIyMjIyMjIyMjIyMjIyBVU0VSIEdVRVNTRUQgV1JPTkcgIyMjIyMjIyMjIyMjI1xuICAgICAgICBpZiAoIXdvcmRzW2NvdW50XS5pc0luY2x1ZGVkKGtleSkgJiYgY2FuSW5jU2NvcmVzID09PSB0cnVlICYmIGNoYW5jZXMgPj0gMSAmJiBhbHBoYWJldFRlc3RQYXN0ICYmICFndWVzc2VkTGV0dGVycy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBjaGFuY2VzLS07XG4gICAgICAgICAgICBndWVzc2VkTGV0dGVycy5wdXNoKGtleSk7XG4gICAgICAgICAgICBtYWtlRWxlbSgpLmFkZENsYXNzKCd3cm9uZy1sZXR0ZXInKS50ZXh0KGtleSkuYXBwZW5kVG8od3JvbmdHdWVzc2VzRGl2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICMjIyMjIyMjIyMgVVNFUiBFWEhBVVNUUyBBTEwgSElTIEdVRVNTRVMgIyMjIyMjIyMjIyMjIyNcbiAgICAgICAgaWYoIWNoYW5jZXMpIHtcbiAgICAgICAgICAgIGFja25vd2xlZGdlR3Vlc3NlcyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gYWxlcnQoJ1lvdSBsb3N0IScpO1xuICAgICAgICAgICAgLy8gY291bnQgPSBpbmMoKTtcbiAgICAgICAgICAgIG1vZGFsTWVzc2FnZS5odG1sKGA8c3BhbiBjbGFzcz1cIm1vZGFsX19oZWFkaW5nLS1sb3NzXCI+WW91IGxvc2UhPC9zcGFuPiBcbiAgICAgICAgICAgIDxicj4gXG4gICAgICAgICAgICBUaGUgd29yZCB3YXMgPHNwYW4gY2xhc3M9XCJtb2RhbF9fbm90YWJsZS0tbG9zc1wiPlwiJHt3b3Jkc1tjb3VudF0ud29yZH1cIjwvc3Bhbj5cbiAgICAgICAgICAgIDxicj5cbiAgICAgICAgICAgIFByZXNzIDxzcGFuIGNsYXNzPVwibW9kYWxfX25vdGFibGUtLWxvc3NcIj5cIkVudGVyXCI8L3NwYW4+IHRvIHN0YXJ0IG92ZXIuYCk7XG4gICAgICAgIG1vZGFsQmFja2Ryb3Auc2hvdygpO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICAgICAgICAgICAgY291bnQgPSBpbmMoKTtcbiAgICAgICAgICAgICAgICBtb2RhbEJhY2tkcm9wLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB3cm9uZ0d1ZXNzZXNEaXYuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICBhY2tub3dsZWRnZUd1ZXNzZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdvcmQgPSB3b3Jkc1tjb3VudF0ud29yZDtcbiAgICAgICAgICAgICAgICBwdXp6bGVXb3JkID0gbWFrZURhc2hlcyh3b3JkKTtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IFtdOyAgXG4gICAgICAgICAgICAgICAgY2hhbmNlcyA9IDU7ICAgICAgXG4gICAgICAgICAgICAgICAgd29yZFByb2dyZXNzRGl2XG4gICAgICAgICAgICAgICAgLnRleHQocHV6emxlV29yZCk7IFxuICAgICAgICAgICAgfVxuICAgICAgICB9IFxuXG4gICAgICAgIC8vICBwbGF5ZXIgY29tcGxldGVkIGV2ZXJ5IHdvcmQgLS0tLS1UT0RPLS0tLS1cbiAgICAgICAgLy8gaWYgKHdpbnMgPT09IHdvcmRzLmxlbmd0aCkge1xuICAgICAgICAvLyAgICAgYWxlcnQoJ1ZJQ1RPUlkhISEhIScpO1xuICAgICAgICAvLyB9XG4gICAgICAgIFxuICAgICAgICAvLyAjIyMjIyMjIyMjIyMjIyMjIFVTRVIgR09UIEFMTCBUSEUgTEVUVEVSUyAjIyMjIyMjIyMjIyMjIyNcbiAgICAgICAgaWYgKHdvcmRzW2NvdW50XS5pc01hdGNoZWQocHV6emxlV29yZCkpIHtcbiAgICAgICAgICAgIGlmIChjYW5JbmNTY29yZXMpIHdpbnMrKztcbiAgICAgICAgICAgIGNhbkluY1Njb3JlcyA9IGZhbHNlO1xuICAgICAgICAgICAgd2luc0Rpdi5odG1sKGB3aW5zOiA8c3BhbiBjbGFzcz1cImdhbWVfX3Njb3JlLS10YWxseVwiPiR7d2luc308L3NwYW4+YCk7XG4gICAgICAgICAgICB3b3JkUHJvZ3Jlc3NEaXZcbiAgICAgICAgICAgIC50ZXh0KGBXb3JkIHNvIGZhcjogJHtwdXp6bGVXb3JkfWApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBtb2RhbFdvcmREaXNwbGF5LnRleHQocHV6emxlV29yZCk7XG4gICAgICAgICAgICBtb2RhbE1lc3NhZ2UuaHRtbChgPHNwYW4gY2xhc3M9XCJtb2RhbF9faGVhZGluZy0td2luXCI+Q29uZ3JhdHVsYXRpb25zITwvc3Bhbj4gXG4gICAgICAgICAgICAgICAgPGJyPiBcbiAgICAgICAgICAgICAgICBZb3UncmUgY29ycmVjdC4gVGhlIHdvcmQncyA8c3BhbiBjbGFzcz1cIm1vZGFsX19ub3RhYmxlLS13aW5cIj5cIiR7cHV6emxlV29yZH1cIjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8YnI+XG4gICAgICAgICAgICAgICAgUHJlc3MgPHNwYW4gY2xhc3M9XCJtb2RhbF9fbm90YWJsZS0td2luXCI+XCJFbnRlclwiPC9zcGFuPiB0byBhdHRlbXB0IHRoZSBuZXh0IHdvcmQuYCk7XG4gICAgICAgICAgICBtb2RhbEJhY2tkcm9wLnNob3coKTtcblxuICAgICAgICAgICAgLy8gbW92ZSB0byBuZXh0IHdvcmQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGVudGVyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgICAgICAgICBjYW5JbmNTY29yZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vICMjIyMjIyBVU0VSIEdPVCBBTEwgVEhFIFdPUkRTICMjIyMjIyMjXG4gICAgICAgICAgICAgICAgaWYgKHdvcmRzW2NvdW50XSAhPT0gd29yZHNbd29yZHMubGVuZ3RoLTFdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICB0byBuZXh0IHdvcmQgYW5kIHJlc2V0IG5lZ2F0aXZlIHJlY29yZCByZWdhcmRpbmcgZWF0IGluZGl2aWR1YWwgd29yZFxuICAgICAgICAgICAgICAgICAgICBzb2Z0UmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kYWxCYWNrZHJvcC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGdhbWUgcmVzZXRzIHdoZW4gYWxsIHRoZSB3b3JkcyBoYXZlIGJlZW4gc29sdmVkXG4gICAgICAgICAgICAgICAgICAgaGFyZFJlc2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjaGFuY2VzRGl2Lmh0bWwoYGNoYW5jZXM6IDxzcGFuIGNsYXNzPVwiZ2FtZV9fc2NvcmUtLXRhbGx5XCI+JHtjaGFuY2VzfTwvc3Bhbj5gKTtcbiAgICAgICAgd29yZFByb2dyZXNzRGl2XG4gICAgICAgICAgICAudGV4dChwdXp6bGVXb3JkKTtcbiAgICBcbiAgICB9O1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PSBFVkVOVCBIQU5ETEVSIEZPUiBTVEFSVElORyBHQU1FPT09PT09PT09PT09PT09PT09PT09PT1cbmNvbnN0IGhhbmRsZUtleXByZXNzID0gKGUpID0+IHtcbiAgICBjb25zdCB7a2V5LCB0YXJnZXR9ID0gZTtcblxuICAgIGNvbnN0IGludHJvID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmludHJvJylcbiAgICBcbiAgICBpZiAoa2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgIGdhbWVDb25maWcoZ2FtZVdvcmRzLCBtZXRob2RzQXJyKTtcbiAgICAgICAgaW50cm8uY2xhc3NMaXN0LmFkZCgnaW50cm8tLXJlbW92ZScpO1xuXG4gICAgICAgIC8vIHJlbW92ZSBsaXN0ZW5lciBzbyB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgb25seSBydW4gb25jZSwgd2hlbiB0aGUgdXNlciBpbml0aWFsbHkgY29tZXMgdG8gdGhlIHNpdGVcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgaGFuZGxlS2V5cHJlc3MpO1xuICAgIH1cbiAgICBcblxufTtcblxuZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwia2V5cHJlc3NcIiwgaGFuZGxlS2V5cHJlc3MpO1xuXG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvYXBwLmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBQ0E7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBOztBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zdHlsZS9tYWluLnNjc3M/NDYwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3N0eWxlL21haW4uc2Nzc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ })
/******/ ]);