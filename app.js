/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__style_main_scss__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__style_main_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__style_main_scss__);\n\n//import styles\n\n\n\nconst HANGMAN = {};\n\n// -------------------------NAMESPACE -------------------------\n(namespace => {\n\t// -----------------------WORD CLASS------------------------\n\t// used to make words for game\n\tclass Word {\n\t\tconstructor(word) {\n\t\t\tthis.word = word.toLowerCase();\n\n\t\t\tthis.isMatched = this.isMatched.bind(this);\n\t\t\tthis.isIncluded = this.isIncluded.bind(this);\n\t\t}\n\n\t\t// method to test if user letter choice is present in word\n\t\tisIncluded(char) {\n\t\t\treturn this.word.includes(char.toLowerCase().trim());\n\t\t}\n\n\t\t//method to test if word is correct\n\t\tisMatched(letters) {\n\t\t\treturn this.word === letters.toLowerCase().trim() ? true : false;\n\t\t}\n\t}\n\n\t// ----------------------WORD FACTORY------------------------\n\t// make single word or an array of words and make it a property of HANGMAN\n\t// it takes an a single string, multiple stings, or an array of stings as an argument\n\tHANGMAN.wordFactory = (...word) => {\n\t\t// if argument is an array make it an array by destructuring it\n\t\tif (Array.isArray(...word)) [word] = word;\n\n\t\t// iterate through an array of strings and return an array of objects\n\t\tif (word.length > 1) return word.map(item => new Word(item));\n\n\t\t// if argument is a single string destructure the array and output a string\n\t\tconst [singleWord] = word;\n\n\t\t// make a single object\n\t\treturn new Word(singleWord);\n\t};\n\n\t// ------------------ARRAY ITERATOR ----------------------------------\n\n\t// loop through array of words and execute callback function using recursive function\n\tconst arrayIterator = (wordList, cb) => {\n\t\tconst [a, ...b] = wordList;\n\t\tcb(a);\n\t\tif (wordList.length === 1) return;\n\t\tarrayIterator(b, cb);\n\t};\n\n\tHANGMAN.arrayIterator = arrayIterator;\n\n\t// This method takes in a string and outputs a string of underscores\n\t// proportionate to the number of characters contained in the string\n\tconst makeDashes = answer => {\n\t\tlet dashed = [];\n\t\t(function looper(answer) {\n\t\t\tlet [a, ...b] = [...answer];\n\n\t\t\tdashed.push('?');\n\t\t\tif (answer.length === 1) return;\n\t\t\tlooper(b);\n\t\t})(answer);\n\t\treturn dashed.join('');\n\t};\n\n\tHANGMAN.makeDashes = makeDashes;\n\n\t// this is a method used for DOM manipulation\n\t// the names of the functions within it borrow from jQuery\n\tconst makeElem = elemName => {\n\t\tlet elem = document.createElement(elemName = 'div');\n\n\t\t// insert element into another element\n\t\telem.appendTo = parent => {\n\t\t\tparent.appendChild(elem);\n\t\t\treturn elem;\n\t\t};\n\n\t\t// add text to element\n\t\telem.text = text => {\n\t\t\telem.textContent = text;\n\t\t\treturn elem;\n\t\t};\n\n\t\t// add HTML to element\n\t\telem.html = html => {\n\t\t\telem.innerHTML = html;\n\t\t\treturn elem;\n\t\t};\n\n\t\t// empty the element of all it's content\n\t\telem.empty = () => {\n\t\t\telem.innerHTML = '';\n\t\t\treturn elem;\n\t\t};\n\n\t\t// hide the element\n\t\telem.hide = () => {\n\t\t\telem.style.visibility = 'hidden';\n\t\t\treturn elem;\n\t\t};\n\n\t\t// show element\n\t\telem.show = () => {\n\t\t\telem.style.visibility = 'visible';\n\t\t\treturn elem;\n\t\t};\n\n\t\t// add CSS class to element\n\t\telem.addClass = className => {\n\t\t\telem.classList.add(className);\n\t\t\treturn elem;\n\t\t};\n\n\t\t// remove CSS class from element\n\t\telem.removeClass = className => {\n\t\t\telem.classList.remove(className);\n\t\t\treturn elem;\n\t\t};\n\n\t\treturn elem;\n\t};\n\n\tHANGMAN.makeElem = makeElem;\n\n\t// this takes in two arguments, the answer and the user's guess\n\t// if the letter guess is present in the answer it outputs an array of objects with the\n\t// letter as a string and the index at which the letter is present in the answer string\n\tlet guesses = (answer, letterGuessed) => {\n\t\treturn (\n\t\t\t// spread the characters in the string and place them in an array\n\t\t\t// then iterate through them using the reduce function which returns a array that contains\n\t\t\t// all the letter guessed and the the index at which it is matched in the answers string\n\t\t\t[...answer].reduce((arr, letter, index) => {\n\t\t\t\tif (letterGuessed === letter) {\n\t\t\t\t\tlet obj = {\n\t\t\t\t\t\tkey: letterGuessed,\n\t\t\t\t\t\tindex: index\n\t\t\t\t\t};\n\t\t\t\t\tarr.push(obj);\n\t\t\t\t}\n\t\t\t\treturn arr;\n\t\t\t}, [])\n\t\t);\n\t};\n\n\tHANGMAN.guesses = guesses;\n\n\t// replaces characters in a string where with provided replacement character and index where it should be placed\n\t// it receives two arguments, a string and an array of objects containing a character the user guessed and it's index in the answer\n\t// all characters provided are contained in the answer\n\tconst replace = (word, input) => {\n\t\tlet resultStr = input.reduce((previous, guess) => {\n\t\t\t// insert each letter according to it's provided index\n\t\t\tif (guess.index !== -1) return previous.substring(0, guess.index) + guess.key + previous.substring(guess.index + 1, previous.length);\n\t\t}, word);\n\n\t\t// return altered string as output\n\t\treturn resultStr;\n\t};\n\n\tHANGMAN.replace = replace;\n\n\t// takes in a number increments it by one and returns the incremented number\n\tconst inc = (num = -1) => num + 1;\n\n\tHANGMAN.inc = inc;\n})(HANGMAN);\n\nconst gameWords = HANGMAN.wordFactory(['one', 'compliment', 'deliberate', 'confidence', 'dynamic', 'javascript']);\nconst { makeElem, makeDashes, guesses, replace, inc } = HANGMAN;\nconst methodsArr = [makeElem, makeDashes, guesses, replace, inc];\n\nconst gameConfig = (words, methods) => {\n\n\tconst wrapQuestMark = word => {\n\t\tconst wordArr = [...word].map(letter => {\n\t\t\tif (letter === '?') return `<span class=\"game__word-progress--unsolved\">${letter}</span>`;\n\t\t\treturn letter;\n\t\t});\n\t\treturn wordArr.join('');\n\t};\n\n\tconst [makeElem, makeDashes, guesses, replace, inc] = methods;\n\n\t// create and place elements into DOM\n\tconst game = makeElem().addClass('game').appendTo(document.body);\n\tconst scoreDiv = makeElem().addClass('game__score').appendTo(game);\n\tconst gameWordDiv = makeElem().addClass('.game__word').appendTo(game);\n\tconst wrgGuessesDiv = makeElem().addClass('.game__wrong-guesses').appendTo(game);\n\n\tconst body = document.body;\n\n\t// set initial values for game\n\n\tlet input = [];\n\n\t// this sets the count to zero\n\t// the inc function returns zero when it is passed no arguments\n\t// otherwise it takes a number as an argument and turns that number incremented by 1\n\t// inc(5) is 5 + 1, which returns 6.\n\n\tlet count = inc();\n\n\tlet { word } = words[count];\n\n\tlet wins = 0;\n\n\tlet chances = 5;\n\n\tlet guessedLetters = [];\n\n\tlet puzzleWord = makeDashes(word);\n\n\t// ############ SETTING INITIAL DOM ELEMENTS ###############\n\tlet winsDiv = makeElem().addClass('game__score--wins').html(`wins: <span class=\"game__score--tally\">${wins}</span>`).appendTo(scoreDiv);\n\tlet chancesDiv = makeElem().addClass('game__score--chances').html(`chances: <span class=\"game__score--tally\">${chances}</span>`).appendTo(scoreDiv);\n\tlet wrongGuessesDiv = makeElem().addClass('wrong-guesses').appendTo(wrgGuessesDiv);\n\tlet wordProgressDiv = makeElem().addClass('game__word-progress').html(wrapQuestMark(puzzleWord)).appendTo(gameWordDiv);\n\n\tconst modalBackdrop = makeElem().addClass('modal__backdrop').hide().appendTo(body);\n\tconst modal = makeElem().addClass('modal').appendTo(modalBackdrop);\n\t// const modalWordDisplay = makeElem('h1').addClass('modal--word').appendTo(modal);\n\tconst modalMessage = makeElem().addClass('modal--message').appendTo(modal);\n\t// let victory = false; // ~~~~~~~~ NO USE YET ~~~~~~~~~\n\n\tlet canIncScores = true;\n\tlet acknowledgeGuesses = true;\n\n\tconst softReset = () => {\n\t\tguessedLetters = [];\n\t\tcount = inc(count);\n\t\tword = words[count].word;\n\t\tpuzzleWord = makeDashes(word);\n\t\tinput = [];\n\t\tchances = 5;\n\t\twordProgressDiv.text(`Word so far: ${puzzleWord}`);\n\t\twrongGuessesDiv.empty();\n\t};\n\n\t// RESTARTS GAME -- STARTS FROM THE BEGINNING\n\tconst hardReset = () => {\n\t\tguessedLetters = [];\n\t\tcanIncScores = true;\n\t\tcount = inc();\n\t\tword = words[count].word;\n\t\tpuzzleWord = makeDashes(word);\n\t\tinput = [];\n\t\tchances = 5;\n\t\twins = 0;\n\t\twordProgressDiv.html(wrapQuestMark(puzzleWord));\n\t\twrongGuessesDiv.empty();\n\t\tconsole.log('wins: ', wins);\n\t};\n\n\t// COMMENCE GAME WHEN USER PRESSES THE ENTER KEY\n\tbody.onkeyup = e => {\n\t\tconst isAlphabet = str => /^[a-zA-Z()]$/.test(str);\n\n\t\t// capture key stroke\n\t\tlet { key } = e;\n\n\t\t// if key is a letter turn it to lower case and reassign it to back to key\n\t\tif (isAlphabet(key)) key = key.toLowerCase();\n\n\t\t//\n\t\tlet userGuess = guesses(word, key);\n\n\t\t// this function tests the key entered to find out if it is an alphabetical character\n\t\tconst alphabetTestPast = isAlphabet(key);\n\n\t\t// spread array and push them into the input array\n\t\tif (acknowledgeGuesses) input.push(...userGuess);\n\n\t\tpuzzleWord = replace(puzzleWord, input);\n\n\t\t// ############## USER GUESSED WRONG #############\n\t\tif (!words[count].isIncluded(key) && canIncScores === true && chances >= 1 && alphabetTestPast && !guessedLetters.includes(key)) {\n\t\t\tchances--;\n\t\t\tguessedLetters.push(key);\n\t\t\tmakeElem().addClass('wrong-letter').text(key).appendTo(wrongGuessesDiv);\n\t\t}\n\n\t\t// ########## USER EXHAUSTS ALL HIS GUESSES ##############\n\t\tif (!chances) {\n\t\t\tacknowledgeGuesses = false;\n\t\t\t// alert('You lost!');\n\t\t\t// count = inc();\n\t\t\tmodalMessage.html(`<span class=\"modal__heading--loss\">You lose!</span> \n            <br> \n            The word was <span class=\"modal__notable--loss\">\"${words[count].word}\"</span>\n            <br>\n            Press <span class=\"modal__notable--loss\">\"Enter\"</span> to start over.`);\n\t\t\tmodalBackdrop.show();\n\t\t\tif (key === 'Enter') {\n\t\t\t\tcount = inc();\n\t\t\t\tmodalBackdrop.hide();\n\t\t\t\twrongGuessesDiv.empty();\n\t\t\t\tacknowledgeGuesses = true;\n\t\t\t\tword = words[count].word;\n\t\t\t\tpuzzleWord = makeDashes(word);\n\t\t\t\tinput = [];\n\t\t\t\tchances = 5;\n\t\t\t\twordProgressDiv.html(wrapQuestMark(puzzleWord));\n\t\t\t}\n\t\t}\n\n\t\t// ################ USER GOT ALL THE LETTERS ###############\n\t\tif (words[count].isMatched(puzzleWord)) {\n\t\t\tif (canIncScores) wins++;\n\t\t\tcanIncScores = false;\n\t\t\twinsDiv.html(`wins: <span class=\"game__score--tally\">${wins}</span>`);\n\t\t\twordProgressDiv.text(`Word so far: ${puzzleWord}`);\n\n\t\t\t// modalWordDisplay.text(puzzleWord);\n\t\t\tmodalMessage.html(`<h2 class=\"modal__heading--win\">Congratulations!</h2> \n                \n                <p class=\"modal__notable\">You're correct. The word's <span class=\"modal__notable--win\">\"${puzzleWord}\"</span>\n                Press <span class=\"modal__notable--win\">\"Enter\"</span> to attempt the next word.</p>`);\n\t\t\tmodalBackdrop.show();\n\n\t\t\t//  player completed every word -----TODO-----\n\t\t\tif (wins === words.length) {\n\t\t\t\tmodalMessage.html(`\n                    <h1 class=\"modal__heading--win\">Congratulations</h1>\n                    <p class=\"modal--message\">You've found all the words. Press Enter to over</p>\n                 `);\n\t\t\t}\n\n\t\t\t// move to next word when the user presses enter\n\t\t\tif (key === 'Enter') {\n\t\t\t\tcanIncScores = true;\n\t\t\t\t// ###### USER GOT ALL THE WORDS ########\n\t\t\t\tif (words[count] !== words[words.length - 1]) {\n\t\t\t\t\t//  to next word and reset negative record regarding eat individual word\n\t\t\t\t\tsoftReset();\n\t\t\t\t\tmodalBackdrop.hide();\n\t\t\t\t} else {\n\t\t\t\t\t// the game resets when all the words have been solved\n\t\t\t\t\thardReset();\n\t\t\t\t\tmodalBackdrop.hide();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tchancesDiv.html(`chances: <span class=\"game__score--tally\">${chances}</span>`);\n\t\twinsDiv.html(`wins: <span class=\"game__score--tally\">${wins}</span>`);\n\t\twordProgressDiv.html(wrapQuestMark(puzzleWord));\n\t};\n};\n\n// =================== EVENT HANDLER FOR STARTING GAME=======================\nconst handleKeypress = e => {\n\tconst { key, target } = e;\n\n\tconst intro = document.querySelector('.intro');\n\n\tif (key === 'Enter') {\n\t\tgameConfig(gameWords, methodsArr);\n\t\tintro.classList.add('intro--remove');\n\n\t\t// remove listener so that this function is only run once, when the user initially comes to the site\n\t\ttarget.removeEventListener('keypress', handleKeypress);\n\t}\n};\n\ndocument.body.addEventListener('keypress', handleKeypress);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvYXBwLmpzP2JkOWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy9pbXBvcnQgc3R5bGVzXG5pbXBvcnQgJy4vc3R5bGUvbWFpbi5zY3NzJztcblxuY29uc3QgSEFOR01BTiA9IHt9O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tTkFNRVNQQUNFIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbihuYW1lc3BhY2UgPT4ge1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVdPUkQgQ0xBU1MtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gdXNlZCB0byBtYWtlIHdvcmRzIGZvciBnYW1lXG5cdGNsYXNzIFdvcmQge1xuXHRcdGNvbnN0cnVjdG9yKHdvcmQpIHtcblx0XHRcdHRoaXMud29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0dGhpcy5pc01hdGNoZWQgPSB0aGlzLmlzTWF0Y2hlZC5iaW5kKHRoaXMpO1xuXHRcdFx0dGhpcy5pc0luY2x1ZGVkID0gdGhpcy5pc0luY2x1ZGVkLmJpbmQodGhpcyk7XG5cdFx0fVxuXG5cdFx0Ly8gbWV0aG9kIHRvIHRlc3QgaWYgdXNlciBsZXR0ZXIgY2hvaWNlIGlzIHByZXNlbnQgaW4gd29yZFxuXHRcdGlzSW5jbHVkZWQoY2hhcikge1xuXHRcdFx0cmV0dXJuIHRoaXMud29yZC5pbmNsdWRlcyhjaGFyLnRvTG93ZXJDYXNlKCkudHJpbSgpKTtcblx0XHR9XG5cblx0XHQvL21ldGhvZCB0byB0ZXN0IGlmIHdvcmQgaXMgY29ycmVjdFxuXHRcdGlzTWF0Y2hlZChsZXR0ZXJzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy53b3JkID09PSBsZXR0ZXJzLnRvTG93ZXJDYXNlKCkudHJpbSgpID8gdHJ1ZSA6IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1XT1JEIEZBQ1RPUlktLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gbWFrZSBzaW5nbGUgd29yZCBvciBhbiBhcnJheSBvZiB3b3JkcyBhbmQgbWFrZSBpdCBhIHByb3BlcnR5IG9mIEhBTkdNQU5cblx0Ly8gaXQgdGFrZXMgYW4gYSBzaW5nbGUgc3RyaW5nLCBtdWx0aXBsZSBzdGluZ3MsIG9yIGFuIGFycmF5IG9mIHN0aW5ncyBhcyBhbiBhcmd1bWVudFxuXHRIQU5HTUFOLndvcmRGYWN0b3J5ID0gKC4uLndvcmQpID0+IHtcblx0XHQvLyBpZiBhcmd1bWVudCBpcyBhbiBhcnJheSBtYWtlIGl0IGFuIGFycmF5IGJ5IGRlc3RydWN0dXJpbmcgaXRcblx0XHRpZiAoQXJyYXkuaXNBcnJheSguLi53b3JkKSkgW3dvcmRdID0gd29yZDtcblxuXHRcdC8vIGl0ZXJhdGUgdGhyb3VnaCBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCByZXR1cm4gYW4gYXJyYXkgb2Ygb2JqZWN0c1xuXHRcdGlmICh3b3JkLmxlbmd0aCA+IDEpIHJldHVybiB3b3JkLm1hcChpdGVtID0+IG5ldyBXb3JkKGl0ZW0pKTtcblxuXHRcdC8vIGlmIGFyZ3VtZW50IGlzIGEgc2luZ2xlIHN0cmluZyBkZXN0cnVjdHVyZSB0aGUgYXJyYXkgYW5kIG91dHB1dCBhIHN0cmluZ1xuXHRcdGNvbnN0IFtzaW5nbGVXb3JkXSA9IHdvcmQ7XG5cblx0XHQvLyBtYWtlIGEgc2luZ2xlIG9iamVjdFxuXHRcdHJldHVybiBuZXcgV29yZChzaW5nbGVXb3JkKTtcblx0fTtcblxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS1BUlJBWSBJVEVSQVRPUiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0Ly8gbG9vcCB0aHJvdWdoIGFycmF5IG9mIHdvcmRzIGFuZCBleGVjdXRlIGNhbGxiYWNrIGZ1bmN0aW9uIHVzaW5nIHJlY3Vyc2l2ZSBmdW5jdGlvblxuXHRjb25zdCBhcnJheUl0ZXJhdG9yID0gKHdvcmRMaXN0LCBjYikgPT4ge1xuXHRcdGNvbnN0IFthLCAuLi5iXSA9IHdvcmRMaXN0O1xuXHRcdGNiKGEpO1xuXHRcdGlmICh3b3JkTGlzdC5sZW5ndGggPT09IDEpIHJldHVybjtcblx0XHRhcnJheUl0ZXJhdG9yKGIsIGNiKTtcblx0fTtcblxuXHRIQU5HTUFOLmFycmF5SXRlcmF0b3IgPSBhcnJheUl0ZXJhdG9yO1xuXG5cdC8vIFRoaXMgbWV0aG9kIHRha2VzIGluIGEgc3RyaW5nIGFuZCBvdXRwdXRzIGEgc3RyaW5nIG9mIHVuZGVyc2NvcmVzXG5cdC8vIHByb3BvcnRpb25hdGUgdG8gdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbnRhaW5lZCBpbiB0aGUgc3RyaW5nXG5cdGNvbnN0IG1ha2VEYXNoZXMgPSBhbnN3ZXIgPT4ge1xuXHRcdGxldCBkYXNoZWQgPSBbXTtcblx0XHQoZnVuY3Rpb24gbG9vcGVyKGFuc3dlcikge1xuXHRcdFx0bGV0IFthLCAuLi5iXSA9IFsuLi5hbnN3ZXJdO1xuXG5cdFx0XHRkYXNoZWQucHVzaCgnPycpO1xuXHRcdFx0aWYgKGFuc3dlci5sZW5ndGggPT09IDEpIHJldHVybjtcblx0XHRcdGxvb3BlcihiKTtcblx0XHR9KShhbnN3ZXIpO1xuXHRcdHJldHVybiBkYXNoZWQuam9pbignJyk7XG5cdH07XG5cblx0SEFOR01BTi5tYWtlRGFzaGVzID0gbWFrZURhc2hlcztcblxuXHQvLyB0aGlzIGlzIGEgbWV0aG9kIHVzZWQgZm9yIERPTSBtYW5pcHVsYXRpb25cblx0Ly8gdGhlIG5hbWVzIG9mIHRoZSBmdW5jdGlvbnMgd2l0aGluIGl0IGJvcnJvdyBmcm9tIGpRdWVyeVxuXHRjb25zdCBtYWtlRWxlbSA9IGVsZW1OYW1lID0+IHtcblx0XHRsZXQgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoKGVsZW1OYW1lID0gJ2RpdicpKTtcblxuXHRcdC8vIGluc2VydCBlbGVtZW50IGludG8gYW5vdGhlciBlbGVtZW50XG5cdFx0ZWxlbS5hcHBlbmRUbyA9IHBhcmVudCA9PiB7XG5cdFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbSk7XG5cdFx0XHRyZXR1cm4gZWxlbTtcblx0XHR9O1xuXG5cdFx0Ly8gYWRkIHRleHQgdG8gZWxlbWVudFxuXHRcdGVsZW0udGV4dCA9IHRleHQgPT4ge1xuXHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IHRleHQ7XG5cdFx0XHRyZXR1cm4gZWxlbTtcblx0XHR9O1xuXG5cdFx0Ly8gYWRkIEhUTUwgdG8gZWxlbWVudFxuXHRcdGVsZW0uaHRtbCA9IGh0bWwgPT4ge1xuXHRcdFx0ZWxlbS5pbm5lckhUTUwgPSBodG1sO1xuXHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0fTtcblxuXHRcdC8vIGVtcHR5IHRoZSBlbGVtZW50IG9mIGFsbCBpdCdzIGNvbnRlbnRcblx0XHRlbGVtLmVtcHR5ID0gKCkgPT4ge1xuXHRcdFx0ZWxlbS5pbm5lckhUTUwgPSAnJztcblx0XHRcdHJldHVybiBlbGVtO1xuXHRcdH07XG5cblx0XHQvLyBoaWRlIHRoZSBlbGVtZW50XG5cdFx0ZWxlbS5oaWRlID0gKCkgPT4ge1xuXHRcdFx0ZWxlbS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cdFx0XHRyZXR1cm4gZWxlbTtcblx0XHR9O1xuXG5cdFx0Ly8gc2hvdyBlbGVtZW50XG5cdFx0ZWxlbS5zaG93ID0gKCkgPT4ge1xuXHRcdFx0ZWxlbS5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuXHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0fTtcblxuXHRcdC8vIGFkZCBDU1MgY2xhc3MgdG8gZWxlbWVudFxuXHRcdGVsZW0uYWRkQ2xhc3MgPSBjbGFzc05hbWUgPT4ge1xuXHRcdFx0ZWxlbS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG5cdFx0XHRyZXR1cm4gZWxlbTtcblx0XHR9O1xuXG5cdFx0Ly8gcmVtb3ZlIENTUyBjbGFzcyBmcm9tIGVsZW1lbnRcblx0XHRlbGVtLnJlbW92ZUNsYXNzID0gY2xhc3NOYW1lID0+IHtcblx0XHRcdGVsZW0uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuXHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0fTtcblxuXHRcdHJldHVybiBlbGVtO1xuXHR9O1xuXG5cdEhBTkdNQU4ubWFrZUVsZW0gPSBtYWtlRWxlbTtcblxuXHQvLyB0aGlzIHRha2VzIGluIHR3byBhcmd1bWVudHMsIHRoZSBhbnN3ZXIgYW5kIHRoZSB1c2VyJ3MgZ3Vlc3Ncblx0Ly8gaWYgdGhlIGxldHRlciBndWVzcyBpcyBwcmVzZW50IGluIHRoZSBhbnN3ZXIgaXQgb3V0cHV0cyBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggdGhlXG5cdC8vIGxldHRlciBhcyBhIHN0cmluZyBhbmQgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBsZXR0ZXIgaXMgcHJlc2VudCBpbiB0aGUgYW5zd2VyIHN0cmluZ1xuXHRsZXQgZ3Vlc3NlcyA9IChhbnN3ZXIsIGxldHRlckd1ZXNzZWQpID0+IHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0Ly8gc3ByZWFkIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgYW5kIHBsYWNlIHRoZW0gaW4gYW4gYXJyYXlcblx0XHRcdC8vIHRoZW4gaXRlcmF0ZSB0aHJvdWdoIHRoZW0gdXNpbmcgdGhlIHJlZHVjZSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgYXJyYXkgdGhhdCBjb250YWluc1xuXHRcdFx0Ly8gYWxsIHRoZSBsZXR0ZXIgZ3Vlc3NlZCBhbmQgdGhlIHRoZSBpbmRleCBhdCB3aGljaCBpdCBpcyBtYXRjaGVkIGluIHRoZSBhbnN3ZXJzIHN0cmluZ1xuXHRcdFx0Wy4uLmFuc3dlcl0ucmVkdWNlKChhcnIsIGxldHRlciwgaW5kZXgpID0+IHtcblx0XHRcdFx0aWYgKGxldHRlckd1ZXNzZWQgPT09IGxldHRlcikge1xuXHRcdFx0XHRcdGxldCBvYmogPSB7XG5cdFx0XHRcdFx0XHRrZXk6IGxldHRlckd1ZXNzZWQsXG5cdFx0XHRcdFx0XHRpbmRleDogaW5kZXhcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGFyci5wdXNoKG9iaik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGFycjtcblx0XHRcdH0sIFtdKVxuXHRcdCk7XG5cdH07XG5cblx0SEFOR01BTi5ndWVzc2VzID0gZ3Vlc3NlcztcblxuXHQvLyByZXBsYWNlcyBjaGFyYWN0ZXJzIGluIGEgc3RyaW5nIHdoZXJlIHdpdGggcHJvdmlkZWQgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGFuZCBpbmRleCB3aGVyZSBpdCBzaG91bGQgYmUgcGxhY2VkXG5cdC8vIGl0IHJlY2VpdmVzIHR3byBhcmd1bWVudHMsIGEgc3RyaW5nIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgYSBjaGFyYWN0ZXIgdGhlIHVzZXIgZ3Vlc3NlZCBhbmQgaXQncyBpbmRleCBpbiB0aGUgYW5zd2VyXG5cdC8vIGFsbCBjaGFyYWN0ZXJzIHByb3ZpZGVkIGFyZSBjb250YWluZWQgaW4gdGhlIGFuc3dlclxuXHRjb25zdCByZXBsYWNlID0gKHdvcmQsIGlucHV0KSA9PiB7XG5cdFx0bGV0IHJlc3VsdFN0ciA9IGlucHV0LnJlZHVjZSgocHJldmlvdXMsIGd1ZXNzKSA9PiB7XG5cdFx0XHQvLyBpbnNlcnQgZWFjaCBsZXR0ZXIgYWNjb3JkaW5nIHRvIGl0J3MgcHJvdmlkZWQgaW5kZXhcblx0XHRcdGlmIChndWVzcy5pbmRleCAhPT0gLTEpXG5cdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0cHJldmlvdXMuc3Vic3RyaW5nKDAsIGd1ZXNzLmluZGV4KSArXG5cdFx0XHRcdFx0Z3Vlc3Mua2V5ICtcblx0XHRcdFx0XHRwcmV2aW91cy5zdWJzdHJpbmcoZ3Vlc3MuaW5kZXggKyAxLCBwcmV2aW91cy5sZW5ndGgpXG5cdFx0XHRcdCk7XG5cdFx0fSwgd29yZCk7XG5cblx0XHQvLyByZXR1cm4gYWx0ZXJlZCBzdHJpbmcgYXMgb3V0cHV0XG5cdFx0cmV0dXJuIHJlc3VsdFN0cjtcblx0fTtcblxuXHRIQU5HTUFOLnJlcGxhY2UgPSByZXBsYWNlO1xuXG5cdC8vIHRha2VzIGluIGEgbnVtYmVyIGluY3JlbWVudHMgaXQgYnkgb25lIGFuZCByZXR1cm5zIHRoZSBpbmNyZW1lbnRlZCBudW1iZXJcblx0Y29uc3QgaW5jID0gKG51bSA9IC0xKSA9PiBudW0gKyAxO1xuXG5cdEhBTkdNQU4uaW5jID0gaW5jO1xufSkoSEFOR01BTik7XG5cbmNvbnN0IGdhbWVXb3JkcyA9IEhBTkdNQU4ud29yZEZhY3RvcnkoWydvbmUnLCAnY29tcGxpbWVudCcsICdkZWxpYmVyYXRlJywgJ2NvbmZpZGVuY2UnLCAnZHluYW1pYycsICdqYXZhc2NyaXB0J10pO1xuY29uc3QgeyBtYWtlRWxlbSwgbWFrZURhc2hlcywgZ3Vlc3NlcywgcmVwbGFjZSwgaW5jIH0gPSBIQU5HTUFOO1xuY29uc3QgbWV0aG9kc0FyciA9IFttYWtlRWxlbSwgbWFrZURhc2hlcywgZ3Vlc3NlcywgcmVwbGFjZSwgaW5jXTtcblxuY29uc3QgZ2FtZUNvbmZpZyA9ICh3b3JkcywgbWV0aG9kcykgPT4ge1xuXG4gICAgY29uc3Qgd3JhcFF1ZXN0TWFyayA9ICh3b3JkKSA9PiB7XG4gICAgICAgIGNvbnN0IHdvcmRBcnIgPSBbLi4ud29yZF0ubWFwKChsZXR0ZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChsZXR0ZXIgPT09ICc/JykgcmV0dXJuIGA8c3BhbiBjbGFzcz1cImdhbWVfX3dvcmQtcHJvZ3Jlc3MtLXVuc29sdmVkXCI+JHtsZXR0ZXJ9PC9zcGFuPmA7XG4gICAgICAgICAgICByZXR1cm4gbGV0dGVyO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdvcmRBcnIuam9pbignJyk7XG4gICAgfTtcbiAgICBcblx0Y29uc3QgW21ha2VFbGVtLCBtYWtlRGFzaGVzLCBndWVzc2VzLCByZXBsYWNlLCBpbmNdID0gbWV0aG9kcztcblxuXHQvLyBjcmVhdGUgYW5kIHBsYWNlIGVsZW1lbnRzIGludG8gRE9NXG5cdGNvbnN0IGdhbWUgPSBtYWtlRWxlbSgpXG5cdFx0LmFkZENsYXNzKCdnYW1lJylcblx0XHQuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSk7XG5cdGNvbnN0IHNjb3JlRGl2ID0gbWFrZUVsZW0oKVxuXHRcdC5hZGRDbGFzcygnZ2FtZV9fc2NvcmUnKVxuXHRcdC5hcHBlbmRUbyhnYW1lKTtcblx0Y29uc3QgZ2FtZVdvcmREaXYgPSBtYWtlRWxlbSgpXG5cdFx0LmFkZENsYXNzKCcuZ2FtZV9fd29yZCcpXG5cdFx0LmFwcGVuZFRvKGdhbWUpO1xuXHRjb25zdCB3cmdHdWVzc2VzRGl2ID0gbWFrZUVsZW0oKVxuXHRcdC5hZGRDbGFzcygnLmdhbWVfX3dyb25nLWd1ZXNzZXMnKVxuXHRcdC5hcHBlbmRUbyhnYW1lKTtcblxuXHRjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcblxuXHQvLyBzZXQgaW5pdGlhbCB2YWx1ZXMgZm9yIGdhbWVcblxuXHRsZXQgaW5wdXQgPSBbXTtcblxuXHQvLyB0aGlzIHNldHMgdGhlIGNvdW50IHRvIHplcm9cblx0Ly8gdGhlIGluYyBmdW5jdGlvbiByZXR1cm5zIHplcm8gd2hlbiBpdCBpcyBwYXNzZWQgbm8gYXJndW1lbnRzXG5cdC8vIG90aGVyd2lzZSBpdCB0YWtlcyBhIG51bWJlciBhcyBhbiBhcmd1bWVudCBhbmQgdHVybnMgdGhhdCBudW1iZXIgaW5jcmVtZW50ZWQgYnkgMVxuXHQvLyBpbmMoNSkgaXMgNSArIDEsIHdoaWNoIHJldHVybnMgNi5cblxuXHRsZXQgY291bnQgPSBpbmMoKTtcblxuXHRsZXQgeyB3b3JkIH0gPSB3b3Jkc1tjb3VudF07XG5cblx0bGV0IHdpbnMgPSAwO1xuXG5cdGxldCBjaGFuY2VzID0gNTtcblxuXHRsZXQgZ3Vlc3NlZExldHRlcnMgPSBbXTtcblxuICAgIGxldCBwdXp6bGVXb3JkID0gbWFrZURhc2hlcyh3b3JkKTtcblxuXHQvLyAjIyMjIyMjIyMjIyMgU0VUVElORyBJTklUSUFMIERPTSBFTEVNRU5UUyAjIyMjIyMjIyMjIyMjIyNcblx0bGV0IHdpbnNEaXYgPSBtYWtlRWxlbSgpXG5cdFx0LmFkZENsYXNzKCdnYW1lX19zY29yZS0td2lucycpXG5cdFx0Lmh0bWwoYHdpbnM6IDxzcGFuIGNsYXNzPVwiZ2FtZV9fc2NvcmUtLXRhbGx5XCI+JHt3aW5zfTwvc3Bhbj5gKVxuXHRcdC5hcHBlbmRUbyhzY29yZURpdik7XG5cdGxldCBjaGFuY2VzRGl2ID0gbWFrZUVsZW0oKVxuXHRcdC5hZGRDbGFzcygnZ2FtZV9fc2NvcmUtLWNoYW5jZXMnKVxuXHRcdC5odG1sKGBjaGFuY2VzOiA8c3BhbiBjbGFzcz1cImdhbWVfX3Njb3JlLS10YWxseVwiPiR7Y2hhbmNlc308L3NwYW4+YClcblx0XHQuYXBwZW5kVG8oc2NvcmVEaXYpO1xuXHRsZXQgd3JvbmdHdWVzc2VzRGl2ID0gbWFrZUVsZW0oKVxuXHRcdC5hZGRDbGFzcygnd3JvbmctZ3Vlc3NlcycpXG5cdFx0LmFwcGVuZFRvKHdyZ0d1ZXNzZXNEaXYpO1xuXHRsZXQgd29yZFByb2dyZXNzRGl2ID0gbWFrZUVsZW0oKVxuXHRcdC5hZGRDbGFzcygnZ2FtZV9fd29yZC1wcm9ncmVzcycpXG5cdFx0Lmh0bWwod3JhcFF1ZXN0TWFyayhwdXp6bGVXb3JkKSlcblx0XHQuYXBwZW5kVG8oZ2FtZVdvcmREaXYpO1xuXG5cdGNvbnN0IG1vZGFsQmFja2Ryb3AgPSBtYWtlRWxlbSgpXG5cdFx0LmFkZENsYXNzKCdtb2RhbF9fYmFja2Ryb3AnKVxuXHRcdC5oaWRlKClcblx0XHQuYXBwZW5kVG8oYm9keSk7XG5cdGNvbnN0IG1vZGFsID0gbWFrZUVsZW0oKVxuXHRcdC5hZGRDbGFzcygnbW9kYWwnKVxuXHRcdC5hcHBlbmRUbyhtb2RhbEJhY2tkcm9wKTtcblx0Ly8gY29uc3QgbW9kYWxXb3JkRGlzcGxheSA9IG1ha2VFbGVtKCdoMScpLmFkZENsYXNzKCdtb2RhbC0td29yZCcpLmFwcGVuZFRvKG1vZGFsKTtcblx0Y29uc3QgbW9kYWxNZXNzYWdlID0gbWFrZUVsZW0oKVxuXHRcdC5hZGRDbGFzcygnbW9kYWwtLW1lc3NhZ2UnKVxuXHRcdC5hcHBlbmRUbyhtb2RhbCk7XG5cdC8vIGxldCB2aWN0b3J5ID0gZmFsc2U7IC8vIH5+fn5+fn5+IE5PIFVTRSBZRVQgfn5+fn5+fn5+XG5cblx0bGV0IGNhbkluY1Njb3JlcyA9IHRydWU7XG5cdGxldCBhY2tub3dsZWRnZUd1ZXNzZXMgPSB0cnVlO1xuXG5cdGNvbnN0IHNvZnRSZXNldCA9ICgpID0+IHtcblx0XHRndWVzc2VkTGV0dGVycyA9IFtdO1xuXHRcdGNvdW50ID0gaW5jKGNvdW50KTtcblx0XHR3b3JkID0gd29yZHNbY291bnRdLndvcmQ7XG5cdFx0cHV6emxlV29yZCA9IG1ha2VEYXNoZXMod29yZCk7XG5cdFx0aW5wdXQgPSBbXTtcblx0XHRjaGFuY2VzID0gNTtcblx0XHR3b3JkUHJvZ3Jlc3NEaXYudGV4dChgV29yZCBzbyBmYXI6ICR7cHV6emxlV29yZH1gKTtcblx0XHR3cm9uZ0d1ZXNzZXNEaXYuZW1wdHkoKTtcblx0fTtcblxuXHQvLyBSRVNUQVJUUyBHQU1FIC0tIFNUQVJUUyBGUk9NIFRIRSBCRUdJTk5JTkdcblx0Y29uc3QgaGFyZFJlc2V0ID0gKCkgPT4ge1xuXHRcdGd1ZXNzZWRMZXR0ZXJzID0gW107XG5cdFx0Y2FuSW5jU2NvcmVzID0gdHJ1ZTtcblx0XHRjb3VudCA9IGluYygpO1xuXHRcdHdvcmQgPSB3b3Jkc1tjb3VudF0ud29yZDtcblx0XHRwdXp6bGVXb3JkID0gbWFrZURhc2hlcyh3b3JkKTtcblx0XHRpbnB1dCA9IFtdO1xuXHRcdGNoYW5jZXMgPSA1O1xuXHRcdHdpbnMgPSAwO1xuXHRcdHdvcmRQcm9ncmVzc0Rpdi5odG1sKHdyYXBRdWVzdE1hcmsocHV6emxlV29yZCkpO1xuICAgICAgICB3cm9uZ0d1ZXNzZXNEaXYuZW1wdHkoKTtcbiAgICAgICAgY29uc29sZS5sb2coJ3dpbnM6ICcsIHdpbnMpO1xuXHR9O1xuXG5cdC8vIENPTU1FTkNFIEdBTUUgV0hFTiBVU0VSIFBSRVNTRVMgVEhFIEVOVEVSIEtFWVxuXHRib2R5Lm9ua2V5dXAgPSBlID0+IHtcblx0XHRjb25zdCBpc0FscGhhYmV0ID0gc3RyID0+IC9eW2EtekEtWigpXSQvLnRlc3Qoc3RyKTtcblxuXHRcdC8vIGNhcHR1cmUga2V5IHN0cm9rZVxuXHRcdGxldCB7IGtleSB9ID0gZTtcblxuXHRcdC8vIGlmIGtleSBpcyBhIGxldHRlciB0dXJuIGl0IHRvIGxvd2VyIGNhc2UgYW5kIHJlYXNzaWduIGl0IHRvIGJhY2sgdG8ga2V5XG5cdFx0aWYgKGlzQWxwaGFiZXQoa2V5KSkga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG5cblx0XHQvL1xuXHRcdGxldCB1c2VyR3Vlc3MgPSBndWVzc2VzKHdvcmQsIGtleSk7XG5cblx0XHQvLyB0aGlzIGZ1bmN0aW9uIHRlc3RzIHRoZSBrZXkgZW50ZXJlZCB0byBmaW5kIG91dCBpZiBpdCBpcyBhbiBhbHBoYWJldGljYWwgY2hhcmFjdGVyXG5cdFx0Y29uc3QgYWxwaGFiZXRUZXN0UGFzdCA9IGlzQWxwaGFiZXQoa2V5KTtcblxuXHRcdC8vIHNwcmVhZCBhcnJheSBhbmQgcHVzaCB0aGVtIGludG8gdGhlIGlucHV0IGFycmF5XG5cdFx0aWYgKGFja25vd2xlZGdlR3Vlc3NlcykgaW5wdXQucHVzaCguLi51c2VyR3Vlc3MpO1xuXG4gICAgICAgIHB1enpsZVdvcmQgPSByZXBsYWNlKHB1enpsZVdvcmQsIGlucHV0KTtcbiAgICAgICAgXG5cdFx0Ly8gIyMjIyMjIyMjIyMjIyMgVVNFUiBHVUVTU0VEIFdST05HICMjIyMjIyMjIyMjIyNcblx0XHRpZiAoXG5cdFx0XHQhd29yZHNbY291bnRdLmlzSW5jbHVkZWQoa2V5KSAmJlxuXHRcdFx0Y2FuSW5jU2NvcmVzID09PSB0cnVlICYmXG5cdFx0XHRjaGFuY2VzID49IDEgJiZcblx0XHRcdGFscGhhYmV0VGVzdFBhc3QgJiZcblx0XHRcdCFndWVzc2VkTGV0dGVycy5pbmNsdWRlcyhrZXkpXG5cdFx0KSB7XG5cdFx0XHRjaGFuY2VzLS07XG5cdFx0XHRndWVzc2VkTGV0dGVycy5wdXNoKGtleSk7XG5cdFx0XHRtYWtlRWxlbSgpXG5cdFx0XHRcdC5hZGRDbGFzcygnd3JvbmctbGV0dGVyJylcblx0XHRcdFx0LnRleHQoa2V5KVxuXHRcdFx0XHQuYXBwZW5kVG8od3JvbmdHdWVzc2VzRGl2KTtcblx0XHR9XG5cblx0XHQvLyAjIyMjIyMjIyMjIFVTRVIgRVhIQVVTVFMgQUxMIEhJUyBHVUVTU0VTICMjIyMjIyMjIyMjIyMjXG5cdFx0aWYgKCFjaGFuY2VzKSB7XG5cdFx0XHRhY2tub3dsZWRnZUd1ZXNzZXMgPSBmYWxzZTtcblx0XHRcdC8vIGFsZXJ0KCdZb3UgbG9zdCEnKTtcblx0XHRcdC8vIGNvdW50ID0gaW5jKCk7XG5cdFx0XHRtb2RhbE1lc3NhZ2UuaHRtbChgPHNwYW4gY2xhc3M9XCJtb2RhbF9faGVhZGluZy0tbG9zc1wiPllvdSBsb3NlITwvc3Bhbj4gXG4gICAgICAgICAgICA8YnI+IFxuICAgICAgICAgICAgVGhlIHdvcmQgd2FzIDxzcGFuIGNsYXNzPVwibW9kYWxfX25vdGFibGUtLWxvc3NcIj5cIiR7d29yZHNbY291bnRdLndvcmR9XCI8L3NwYW4+XG4gICAgICAgICAgICA8YnI+XG4gICAgICAgICAgICBQcmVzcyA8c3BhbiBjbGFzcz1cIm1vZGFsX19ub3RhYmxlLS1sb3NzXCI+XCJFbnRlclwiPC9zcGFuPiB0byBzdGFydCBvdmVyLmApO1xuXHRcdFx0bW9kYWxCYWNrZHJvcC5zaG93KCk7XG5cdFx0XHRpZiAoa2V5ID09PSAnRW50ZXInKSB7XG5cdFx0XHRcdGNvdW50ID0gaW5jKCk7XG5cdFx0XHRcdG1vZGFsQmFja2Ryb3AuaGlkZSgpO1xuXHRcdFx0XHR3cm9uZ0d1ZXNzZXNEaXYuZW1wdHkoKTtcblx0XHRcdFx0YWNrbm93bGVkZ2VHdWVzc2VzID0gdHJ1ZTtcblx0XHRcdFx0d29yZCA9IHdvcmRzW2NvdW50XS53b3JkO1xuXHRcdFx0XHRwdXp6bGVXb3JkID0gbWFrZURhc2hlcyh3b3JkKTtcblx0XHRcdFx0aW5wdXQgPSBbXTtcblx0XHRcdFx0Y2hhbmNlcyA9IDU7XG5cdFx0XHRcdHdvcmRQcm9ncmVzc0Rpdi5odG1sKHdyYXBRdWVzdE1hcmsocHV6emxlV29yZCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vICMjIyMjIyMjIyMjIyMjIyMgVVNFUiBHT1QgQUxMIFRIRSBMRVRURVJTICMjIyMjIyMjIyMjIyMjI1xuXHRcdGlmICh3b3Jkc1tjb3VudF0uaXNNYXRjaGVkKHB1enpsZVdvcmQpKSB7XG5cdFx0XHRpZiAoY2FuSW5jU2NvcmVzKSB3aW5zKys7XG5cdFx0XHRjYW5JbmNTY29yZXMgPSBmYWxzZTtcblx0XHRcdHdpbnNEaXYuaHRtbChgd2luczogPHNwYW4gY2xhc3M9XCJnYW1lX19zY29yZS0tdGFsbHlcIj4ke3dpbnN9PC9zcGFuPmApO1xuXHRcdFx0d29yZFByb2dyZXNzRGl2LnRleHQoYFdvcmQgc28gZmFyOiAke3B1enpsZVdvcmR9YCk7XG5cblx0XHRcdC8vIG1vZGFsV29yZERpc3BsYXkudGV4dChwdXp6bGVXb3JkKTtcblx0XHRcdG1vZGFsTWVzc2FnZS5odG1sKGA8aDIgY2xhc3M9XCJtb2RhbF9faGVhZGluZy0td2luXCI+Q29uZ3JhdHVsYXRpb25zITwvaDI+IFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwibW9kYWxfX25vdGFibGVcIj5Zb3UncmUgY29ycmVjdC4gVGhlIHdvcmQncyA8c3BhbiBjbGFzcz1cIm1vZGFsX19ub3RhYmxlLS13aW5cIj5cIiR7cHV6emxlV29yZH1cIjwvc3Bhbj5cbiAgICAgICAgICAgICAgICBQcmVzcyA8c3BhbiBjbGFzcz1cIm1vZGFsX19ub3RhYmxlLS13aW5cIj5cIkVudGVyXCI8L3NwYW4+IHRvIGF0dGVtcHQgdGhlIG5leHQgd29yZC48L3A+YCk7XG5cdFx0XHRtb2RhbEJhY2tkcm9wLnNob3coKTtcblxuICAgICAgICAgICAgLy8gIHBsYXllciBjb21wbGV0ZWQgZXZlcnkgd29yZCAtLS0tLVRPRE8tLS0tLVxuICAgICAgICAgICAgaWYgKHdpbnMgPT09IHdvcmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG1vZGFsTWVzc2FnZS5odG1sKGBcbiAgICAgICAgICAgICAgICAgICAgPGgxIGNsYXNzPVwibW9kYWxfX2hlYWRpbmctLXdpblwiPkNvbmdyYXR1bGF0aW9uczwvaDE+XG4gICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwibW9kYWwtLW1lc3NhZ2VcIj5Zb3UndmUgZm91bmQgYWxsIHRoZSB3b3Jkcy4gUHJlc3MgRW50ZXIgdG8gb3ZlcjwvcD5cbiAgICAgICAgICAgICAgICAgYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcblx0XHRcdC8vIG1vdmUgdG8gbmV4dCB3b3JkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBlbnRlclxuXHRcdFx0aWYgKGtleSA9PT0gJ0VudGVyJykge1xuXHRcdFx0XHRjYW5JbmNTY29yZXMgPSB0cnVlO1xuXHRcdFx0XHQvLyAjIyMjIyMgVVNFUiBHT1QgQUxMIFRIRSBXT1JEUyAjIyMjIyMjI1xuXHRcdFx0XHRpZiAod29yZHNbY291bnRdICE9PSB3b3Jkc1t3b3Jkcy5sZW5ndGggLSAxXSkge1xuXHRcdFx0XHRcdC8vICB0byBuZXh0IHdvcmQgYW5kIHJlc2V0IG5lZ2F0aXZlIHJlY29yZCByZWdhcmRpbmcgZWF0IGluZGl2aWR1YWwgd29yZFxuXHRcdFx0XHRcdHNvZnRSZXNldCgpO1xuXHRcdFx0XHRcdG1vZGFsQmFja2Ryb3AuaGlkZSgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHRoZSBnYW1lIHJlc2V0cyB3aGVuIGFsbCB0aGUgd29yZHMgaGF2ZSBiZWVuIHNvbHZlZFxuXHRcdFx0XHRcdGhhcmRSZXNldCgpO1xuXHRcdFx0XHRcdG1vZGFsQmFja2Ryb3AuaGlkZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG4gICAgICAgIGNoYW5jZXNEaXYuaHRtbChgY2hhbmNlczogPHNwYW4gY2xhc3M9XCJnYW1lX19zY29yZS0tdGFsbHlcIj4ke2NoYW5jZXN9PC9zcGFuPmApO1xuICAgICAgICB3aW5zRGl2Lmh0bWwoYHdpbnM6IDxzcGFuIGNsYXNzPVwiZ2FtZV9fc2NvcmUtLXRhbGx5XCI+JHt3aW5zfTwvc3Bhbj5gKTtcblx0XHR3b3JkUHJvZ3Jlc3NEaXYuaHRtbCh3cmFwUXVlc3RNYXJrKHB1enpsZVdvcmQpKTtcblx0fTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT0gRVZFTlQgSEFORExFUiBGT1IgU1RBUlRJTkcgR0FNRT09PT09PT09PT09PT09PT09PT09PT09XG5jb25zdCBoYW5kbGVLZXlwcmVzcyA9IGUgPT4ge1xuXHRjb25zdCB7IGtleSwgdGFyZ2V0IH0gPSBlO1xuXG5cdGNvbnN0IGludHJvID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmludHJvJyk7XG5cblx0aWYgKGtleSA9PT0gJ0VudGVyJykge1xuXHRcdGdhbWVDb25maWcoZ2FtZVdvcmRzLCBtZXRob2RzQXJyKTtcblx0XHRpbnRyby5jbGFzc0xpc3QuYWRkKCdpbnRyby0tcmVtb3ZlJyk7XG5cblx0XHQvLyByZW1vdmUgbGlzdGVuZXIgc28gdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgcnVuIG9uY2UsIHdoZW4gdGhlIHVzZXIgaW5pdGlhbGx5IGNvbWVzIHRvIHRoZSBzaXRlXG5cdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgaGFuZGxlS2V5cHJlc3MpO1xuXHR9XG59O1xuXG5kb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgaGFuZGxlS2V5cHJlc3MpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9hcHAuanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBQ0E7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFHQTtBQUNBO0FBSUE7QUFJQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zdHlsZS9tYWluLnNjc3M/NDYwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3N0eWxlL21haW4uc2Nzc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ })
/******/ ]);